<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>14. 闭包（Closures）</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="a563a90e-7f4c-48aa-8398-9fb20044d690" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/gradients_2.png" style="object-position:center 19.999999999999996%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🚔</span></div><h1 class="page-title">14. 闭包（Closures）</h1></header><div class="page-body"><div id="662d729c-f9bf-4e8b-9447-179f24ff7cad" class="column-list"><div id="a42ac9d7-7b94-4b14-9f2d-91589539dc8a" style="width:12.5%" class="column"><nav id="5f74082c-adb5-4713-9893-c735aad67940" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#71abdaea-4aef-4554-a017-41af6e361806">14.1 闭包</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#abffd0ff-267a-48b5-9977-172ae26d0442">14.1.1 定义</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3c4e6a7b-8cf6-462c-a258-c4e5aa254870">14.1.2 理解闭包</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7b170185-1478-4fae-badd-95ee5acccfcb">14.2 闭包中的this对象</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5f52960f-5722-4e45-8050-bebf119cc63b">14.3 内存泄漏（Memory Leaks）</a></div></nav><p id="367ac0e9-44e4-46a9-b962-5dca2f46d7f1" class="">
</p></div><div id="35a8ca8c-3094-4205-9ece-c9019b4debea" style="width:87.5%" class="column"><h1 id="71abdaea-4aef-4554-a017-41af6e361806" class="">14.1 闭包</h1><h2 id="abffd0ff-267a-48b5-9977-172ae26d0442" class="">14.1.1 定义</h2><ul id="cb8d0250-a8c0-4d7d-8613-1ece46c3978c" class="bulleted-list"><li style="list-style-type:disc"><strong>匿名函数</strong>（<strong>anonymous functions</strong>）常被人误认为是<strong>闭包</strong>（<strong>closure</strong>），闭包实际上是那些<strong>引用了</strong>（<strong>have access to</strong>）另外一个<strong>函数作用域</strong>（<strong>function’s scope</strong>）中的变量的函数，通常在嵌套函数（creating a function inside a function）中<strong>实现</strong>（<strong>accomplished</strong>）</li></ul><ul id="1d75a4c9-f7f0-490f-96cd-434f1bd77612" class="bulleted-list"><li style="list-style-type:disc">在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">MDN</a>中，闭包是一个与<strong>周边环境状态</strong>【<strong>surrounding state（the lexical environment ，词法环境）</strong>】中的引用（<strong>references</strong>）<strong>捆绑在一起</strong>（<strong>bundled together</strong>）的<strong>函数组合</strong>（<strong>the combination of a function</strong>）</li></ul><ul id="d97f9454-7015-4959-bae1-a51d091e0189" class="bulleted-list"><li style="list-style-type:disc">这两种定义都表明闭包的两个特性<ul id="3562268d-6405-4701-90f0-db5357439d7d" class="bulleted-list"><li style="list-style-type:circle">闭包本质上是一个函数</li></ul><ul id="9e58fa94-984d-4ddf-95d6-7a5b2bf48a76" class="bulleted-list"><li style="list-style-type:circle">这个函数引用不属于它作用域的（通常为另外一个函数作用域的）变量</li></ul></li></ul><hr id="18a41c8a-d85d-460f-8425-5c1cef06346d"/><ul id="4f524161-c1c1-4f01-a631-00d3c3023f55" class="bulleted-list"><li style="list-style-type:disc"><strong>例子：</strong>在之前的函数作为返回值中实际上声明的一个创建比较函数的函数，其返回的匿名函数就是一个闭包，因为这个匿名函数引用了外部函数作用域中的<code>prop</code>参数，如下<pre id="93e02ecb-b885-4bfa-ae24-21319317a16f" class="code code-wrap"><code>function createComparisionFunction(prop) {
  return function (a, b) {
    let v1 = a[prop];
    let v2 = b[prop];
    if (v1 &lt; v2) {
      return -1;
    } else if (v1 &gt; v2) {
      return 1;
    } else {
      return 0;
    }
  };
}</code></pre><ul id="e102f424-a6f4-4d3d-b902-4e1a6105db6b" class="bulleted-list"><li style="list-style-type:circle">黄色背景的代码位于内部函数（匿名函数）中，它<strong>引用着</strong>（<strong>accessing</strong>）外部函数的变量<code>prop</code> </li></ul><ul id="ddd39f05-a6d0-4c38-9f56-13ea993f4b71" class="bulleted-list"><li style="list-style-type:circle">即使这个内部函数被返回并在其它地方使用，它仍然<strong>引用着</strong>（<strong>accessing</strong>）那个变量</li></ul><ul id="93dcffeb-7aa3-4ed8-a813-f5863cbbe6b8" class="bulleted-list"><li style="list-style-type:circle">要理解为何这个匿名函数能一直引用<code>prop</code> ，需要思考当第一次调用这个函数（<code>createComparisonFunction()</code>）时会发生什么</li></ul></li></ul><h2 id="3c4e6a7b-8cf6-462c-a258-c4e5aa254870" class="">14.1.2 理解闭包</h2><ul id="1d3dbfed-243b-4aa4-acf0-0a40486a85fd" class="bulleted-list"><li style="list-style-type:disc">在<a href="../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.html"><span class="icon">🥉</span>4. 变量、作用域与内存</a> 中介绍过<strong>作用域链</strong>（<strong>scope chain</strong>）的概念，理解<strong>作用域链的创建和使用细节</strong>对理解闭包非常重要</li></ul><ul id="34473192-9a47-4a47-9241-715d70df4a34" class="bulleted-list"><li style="list-style-type:disc">在调用函数过程中，作用域链的创建细节如下<ol type="1" id="c1ec8693-1801-4c8a-8308-50d05daecbf5" class="numbered-list" start="1"><li>在调用一个函数时，会为这个函数调用创建一个<strong>执行上下文</strong>（<strong>execution context</strong>），并且函数的作用域链也被创建。</li></ol><ol type="1" id="9d29908c-5993-46fd-99dd-cc18729af4a6" class="numbered-list" start="2"><li>然后用一个<code>arguments</code> 和其它命名参数来初始化这个函数的<strong>活动对象</strong>（<strong>activation object</strong>）。</li></ol><ol type="1" id="7408bb95-1396-4495-986b-df3a339dccc8" class="numbered-list" start="3"><li>外部函数的活动对象是内部函数作用域链上的第二个对象（内部函数作用域链上的第一个对象是它自身的活动对象）</li></ol><ol type="1" id="7cb9be4c-5774-4d97-afca-bc5cac85466b" class="numbered-list" start="4"><li>内部函数作用域链（<code>process</code>）一直向外串起了所有包含函数的活动对象，<strong>直到</strong>（<strong>terminates</strong>）全局执行上下文才终止。</li></ol></li></ul><ul id="886bfb0e-7f87-4cd0-a7cc-e701f4e54387" class="bulleted-list"><li style="list-style-type:disc">在函数执行过程中，要从作用域链中查找变量，以便读、写值<pre id="04c55b94-a81d-4314-9726-385ad28b4f74" class="code code-wrap"><code>function compare(value1, value2) {
  if (value1 &lt; value2) {
    return -1;
  } else if (value1 &gt; value2) {
    return 1;
  } else {
    return 0;
  }
}
let result = compare(5, 10);</code></pre><ul id="567414ae-c5d6-44a6-bb81-763f00e9e1ea" class="bulleted-list"><li style="list-style-type:circle">这里定义的<code>compare()</code> 是在<strong>全局上下文</strong>(<strong>global execution context</strong>)中调用的</li></ul><ul id="907c66cf-8a6a-4763-83e2-373b6b728c69" class="bulleted-list"><li style="list-style-type:circle"><strong>第一次</strong>调用<code>compare()</code> 会为它创建一个包含<code>arguments</code>、<code>value1</code>、<code>value2</code>的<strong>活动对象</strong>（<strong>activation object</strong>）</li></ul><ul id="4dd41b0b-7478-4733-b3ae-527317cc4970" class="bulleted-list"><li style="list-style-type:circle">而<strong>全局上下文的变量对象</strong>（<strong>global context’s variable object</strong>）则是<code>compare()</code> 作用域链上的第二个对象，其中至少包含<code>this</code>， <code>result</code>和<code>compare</code></li></ul><ul id="7dd34bbf-3ef0-46ca-a6f8-202d33bb5df4" class="bulleted-list"><li style="list-style-type:circle">作用域链和执行上下文关系如下<figure id="67130797-5d34-46e3-90b7-586eb1ec6751" class="image"><a href="14%20%E9%97%AD%E5%8C%85%EF%BC%88Closures%EF%BC%89/scope_chain.png"><img style="width:1200px" src="14%20%E9%97%AD%E5%8C%85%EF%BC%88Closures%EF%BC%89/scope_chain.png"/></a></figure></li></ul></li></ul><ul id="991b22a9-58a5-4b72-a321-d074eb01088f" class="bulleted-list"><li style="list-style-type:disc">在函数执行的幕后（behind），每个执行上下文都会有一个<strong>包含其中变量</strong>（<strong>represents the variables</strong>）的对象<ul id="f3ec6c1a-e03b-4525-8c6e-2c5cb56e1679" class="bulleted-list"><li style="list-style-type:circle">全局上下文（<strong>global context</strong>）中叫<strong>变量对象</strong>（<strong>variables object</strong>），它会在代码执行期间始终存在</li></ul><ul id="63103dae-3d09-483e-89e6-9ea52a41207c" class="bulleted-list"><li style="list-style-type:circle">而函数局部上下文中叫<strong>活动对象</strong>（<strong>activation object</strong>），只在函数执行期间存在（例如<code>compare()</code> 函数）</li></ul></li></ul><ul id="2b5d4cf6-b5ae-4517-aaa8-4bd1369c9f44" class="bulleted-list"><li style="list-style-type:disc">在定义<code>compare()</code> 函数时，就会创建作用域链，<strong>预装载（preloaded）</strong>全局<strong>变量对象</strong>（<strong>variables object</strong>），并保存在函数对象<strong>内部</strong>（<strong>internal</strong>）的[[Scope]]属性中<ul id="9489d4ca-e17d-4b29-a8eb-3175b78ae6bd" class="bulleted-list"><li style="list-style-type:circle">在调用这个函数时，会创建相应的执行上下文</li></ul><ul id="a72147d4-e0b3-4af0-b9e6-f367fdbee28e" class="bulleted-list"><li style="list-style-type:circle">然后通过复制函数的[[Scope]]属性来<strong>构建</strong>（<strong>built up</strong>）其作用域链</li></ul><ul id="2de38c9d-be24-42ad-af86-aec572f78507" class="bulleted-list"><li style="list-style-type:circle">接着会创建函数的<strong>活动对象（activation object，</strong>用作局部的变量对象<strong>）</strong>将其推入到（<strong>pushed to</strong>）作用域链的<strong>前端</strong>（<strong>front</strong>）</li></ul><hr id="9332daa5-3504-47e8-9014-e91ea728d1d6"/><ul id="e54bef85-d978-44f2-b86e-ecd043a0c0ce" class="bulleted-list"><li style="list-style-type:circle">在这个的例子，这意味着<code>compare()</code> 函数执行上下文的作用域链中有两个变量对象：<strong>局部</strong>（<strong>local</strong>）变量对象和<strong>全局</strong>（<strong>global</strong>）变量对象</li></ul></li></ul><ul id="39347183-edc6-46a4-b75c-43c302cd7a04" class="bulleted-list"><li style="list-style-type:disc">作用域链实际上是一个包含指针（<strong>pointers</strong>）的列表，每个指针分别指向一个变量对象，但在物理上并不会包含相应的对象</li></ul><ul id="dbd36f90-695c-4343-85e4-f58ab2c05aa7" class="bulleted-list"><li style="list-style-type:disc">函数内部的代码在<strong>访问</strong>（<strong>accessed</strong>）变量时，就会使用给定的名称从作用域链中查找变量；一旦函数指向完毕，局部的活动对象（函数的局部变量对象）会被销毁，内存中就只剩下全局作用域，不过<strong>闭包就不一样</strong>了</li></ul><hr id="2fd2ebf6-284e-435f-bc82-ba97192383b0"/><ul id="c2b2328e-45e9-48da-bb17-39f94fab8aed" class="bulleted-list"><li style="list-style-type:disc">回到<a href="14%20%E9%97%AD%E5%8C%85%EF%BC%88Closures%EF%BC%89.html"><code>createComparisionFunction()</code></a>这个例子中，在一个函数内部定义的函数会把<strong>其包含函数</strong>（<strong>containing function</strong>）的活动对象添加到自己的作用域链中；因此<code>createComparisionFunction()</code> 函数中的匿名函数的作用域链实际上包含<code>createComparisionFunction()</code> 的活动对象，执行如下语句<pre id="79660386-a06f-48f2-b7af-89f20e97cac2" class="code"><code>let compare = createComparisionFunction(&quot;name&quot;);
let result = compare({name: &#x27;Nicholas&#x27;}, {name: &#x27;Matt&#x27;})</code></pre><ul id="abe1ed49-9c42-44de-a02f-a52838ab73aa" class="bulleted-list"><li style="list-style-type:circle">执行完毕后，会得到一个匿名函数的执行上下文及其作用域链，其关系和<code>createComparisionFunction()</code> 函数的上下文及其作用域链的关系图如下<figure id="5f38a1e8-eb4a-43e9-a512-8a48387cecb3" class="image"><a href="14%20%E9%97%AD%E5%8C%85%EF%BC%88Closures%EF%BC%89/Frame_2.png"><img style="width:1200px" src="14%20%E9%97%AD%E5%8C%85%EF%BC%88Closures%EF%BC%89/Frame_2.png"/></a></figure></li></ul><ul id="d4c3e6bb-e226-4373-9dcc-08def73ec918" class="bulleted-list"><li style="list-style-type:circle">在<code>createComparisionFunction()</code> 函数返回匿名函数后，它的作用域链被初始化为包含<code>createComparisionFunction()</code> 的活动对象和全局变量对象，这一匿名函数就可以访问到<code>createComparisionFunction()</code> 函数可以访问到的所有变量</li></ul><ul id="0dfbecc9-277d-4448-9855-239081a75b21" class="bulleted-list"><li style="list-style-type:circle">另外一个<strong>副作用</strong>（<strong>effect</strong>）是<code>createComparisionFunction()</code> 的活动对象并不能在它执行完毕后被销毁，因为匿名函数的作用域链中仍然有对它的活动对象的引用</li></ul></li></ul><ul id="35306d30-c0b0-488f-bf9b-1405d797bf0f" class="bulleted-list"><li style="list-style-type:disc">虽然<code>createComparisionFunction()</code> 执行完毕后，其执行上下文的作用域链会被销毁，但是它的活动对象仍然会保留（remain）在内存中，直到匿名函数被销毁<pre id="9a96b429-df39-4486-adac-eba3db64e7dd" class="code code-wrap"><code>// 创建比较函数
let compareNames = createComparisionFunction(&quot;name&quot;);
// 调用函数
let result = compareNames({ name: &quot;Nicholas&quot; }, { name: &quot;Matt&quot; });
// 销毁compare才会使得createComparisionFunction的活动对象在内存中被释放
compareNames = null;</code></pre><ul id="a4da1fe8-c475-4b95-88e8-5d56fd4787ac" class="bulleted-list"><li style="list-style-type:circle">比较函数被保存在变量<code>compareNames</code>中（仍然是匿名函数），把它设置为<code>null</code> 等价于解除对匿名函数的引用，从而让垃圾回收程序可以将匿名函数所在内存释放</li></ul><ul id="524a411f-c32f-455e-9f20-688dc66d5f6a" class="bulleted-list"><li style="list-style-type:circle">更进一步，匿名函数的作用域链也会被销毁，而作用域链中引用的<code>createComparisionFunction()</code> 函数的活动对象因为失去引用也会被安全销毁</li></ul></li></ul><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="bd341890-4f04-4717-8a7e-b40970ec757a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">注意：因为闭包会<strong>保留</strong>（<strong>carry with</strong>）它们包含（<strong>containing</strong>）函数的作用域，所以比其它函数更占用内存。<strong>过度使用</strong>（<strong>Overuse</strong>）闭包可能导致<strong>内存过度占用</strong>(<strong>excess memory consumption</strong>)，因此建议在十分必要的时候才使用闭包。V8等优化的JavaScript引擎会努力回收被闭包困住的内存，不过还是希望建议在使用闭包时要谨慎</div></figure><h1 id="7b170185-1478-4fae-badd-95ee5acccfcb" class="">14.2 闭包中的this对象</h1><ul id="fb0735b4-67aa-464d-8f10-3e41ae6ee1bb" class="bulleted-list"><li style="list-style-type:disc">在闭包中使用<code>this</code> 会让代码变的复杂，因为在标准函数中<code>this</code> 拥有<strong>运行时绑定</strong>的特性，开发者无法确定闭包中的<code>this</code> 在<strong>未来</strong>会指向哪个对象，如果不指定调用对象，而是直接调用生成的匿名函数，<code>this</code> 一般就是默认的全局对象（严格模式下为<code>undefined</code>）</li></ul><ul id="82275211-9490-4fcd-9e3e-644c030305ad" class="bulleted-list"><li style="list-style-type:disc">现在来看这个例子，它在一个对象中定义了一个生成函数的方法<pre id="836706d4-86df-44d4-bb40-958765bafd01" class="code code-wrap"><code>globalThis.identity = &quot;The Global Object&quot;;

let obj = {
  identity: &quot;My Object&quot;,
  createIdentityFunction() {
    return function () {
      return this.identity;
    };
  },
};
console.log(obj.createIdentityFunction()()); // The Global Object</code></pre><ul id="8e362426-98bd-4dfb-86ae-9be141c40e0d" class="bulleted-list"><li style="list-style-type:circle">从闭包的角度看，匿名函数引用了<code>createIdentityFunction()</code> 的<code>this</code> ，为什么匿名函数没有使用其包含作用域（<code>createIdentityFunction()</code>）的<code>this</code>对象呢？</li></ul></li></ul><ul id="bf4b9d4b-4185-45be-8201-246992be3c57" class="bulleted-list"><li style="list-style-type:disc">实际上，第<a href="9%20%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%EF%BC%88Function%20Internals%EF%BC%89.html"><span class="icon">🪑</span>9. 函数内部（Function Internals）</a> 节的第一句话就能解释这个问题：<div><p id="d7be2941-25a8-4c49-9b99-e93445f23d35" class="">在ES5标准中，函数内部存在两个特殊的对象：<code>arguments</code> 和<code>this</code> ，ES6又新增了<code>new.target</code>属性（关于这个在第八章时就介绍过<a href="../8%20%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/4%20%E7%B1%BB/new%20target.html"><span class="icon">🌑</span>new.target</a> ）</p></div><ul id="6a2a1fe2-7cc7-4e9c-ba7f-aaf0a8814b04" class="bulleted-list"><li style="list-style-type:circle">每个函数在被调用时都会自动创建两个特殊变量：<code>this</code>和<code>arguments</code> </li></ul><ul id="bd03cb1b-5252-42e7-8b57-2ca54eaa74b4" class="bulleted-list"><li style="list-style-type:circle"><strong>内部函数永远不可能直接访问外部函数的这两个变量</strong></li></ul><hr id="c149e27c-7269-4fa7-92a1-7f347eeb515e"/><ul id="954b6fb6-ec44-413f-93a1-b3fc4de05f99" class="bulleted-list"><li style="list-style-type:circle">对于箭头函数而言，因为它<strong>不具有</strong>运行时绑定的特性，而是定义时绑定最近上下文中的<code>this</code> （这点和闭包很像）</li></ul><ul id="2049d4ce-9222-444a-b065-f3f3dfbc2ee9" class="bulleted-list"><li style="list-style-type:circle">所以上述的匿名函数替换为箭头函数打印的就是<code>My Object</code> 了</li></ul></li></ul><ul id="05f06bd0-0b1e-47a2-9555-97bba23c27bb" class="bulleted-list"><li style="list-style-type:disc">虽然内部的标准函数不能访问待外部函数的<code>this</code> ，但是以闭包的观点，内部的标准函数可以访问到其它任何定义在外部函数的变量，那么<strong>把</strong><strong><code>this</code></strong><strong>保存到一个变量中，</strong>那么内部函数就可以通过这个变量间接访问到外部函数的<code>this</code>了！通常可以在外部函数中定义一个<code>that</code> 变量供内部函数使用，如下<pre id="a0793c2f-a8a7-457d-8d8f-7eebbeb106d1" class="code code-wrap"><code>let obj3 = {
  identity: &quot;My Object&quot;,
  createIdentityFunction() {
    let that = this;
    return function () {
      return that.identity;
    };
  },
};
console.log(obj3.createIdentityFunction()()); // My Object</code></pre><ul id="52079aef-666f-4afb-9598-688146c3ee14" class="bulleted-list"><li style="list-style-type:circle">在定义匿名函数前，先把外部函数的<code>this</code> 保存到变量<code>that</code>中，然后定义闭包时，就可以让它访问<code>that</code> ，因为这是包含函数（外部函数）中名称没有任何冲突的一个变量</li></ul><ul id="3bd6a82f-b780-4d65-b4b3-15e61326ff44" class="bulleted-list"><li style="list-style-type:circle">即使外部函数返回后，<code>that</code> 仍然指向<code>obj3</code> ，所以<mark class="highlight-yellow_background"><strong> </strong></mark><code><mark class="highlight-yellow_background"><strong>return that.identity;</strong></mark></code><mark class="highlight-yellow_background"><strong> </strong></mark>自然返回My Object</li></ul><figure class="block-color-red_background callout" style="white-space:pre-wrap;display:flex" id="213e5f49-fdbd-4308-8b05-d8ff06ff7fef"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">注意：<code>this</code> 和<code>arguments</code> 都是不能直接在内部函数中访问的，如果想要访问包含作用域中的arguments对象，则同样需要将其引用先保存到闭包能访问到的另一个变量中</div></figure></li></ul><hr id="7ed0b998-e5e4-4d1b-ae02-6bf119bd3279"/><ul id="aeedc106-a8ee-44a3-ad49-e2f487266851" class="bulleted-list"><li style="list-style-type:disc">另一个解决方案是使用箭头函数，因为箭头函数的<code>this</code> 值默认绑定定义时最近上下文中的<code>this</code><pre id="6ed5c6f5-367b-41a1-8ded-29db6ec02ef1" class="code code-wrap"><code>let obj2 = {
  identity: &quot;My Object&quot;,
  createIdentityFunction() {
    return () =&gt; {
      return this.identity;
    };
  },
};
console.log(obj2.createIdentityFunction()()); // My Object</code></pre></li></ul><hr id="6d9f62d7-b766-4d60-90b3-c2dea05df1ec"/><ul id="be2f420e-f9cc-475b-8a05-65da30ad3f30" class="bulleted-list"><li style="list-style-type:disc">关于<code>this</code> 值更深层次的理解可以查看<a href="https://www.notion.so/this-cb80ad0de9a74f5c999237ed645d9ef1"><span class="icon">📞</span>this操作符</a> ，除此之外，还有几种调用方法时<code>this</code> 的期待可能有所变化的例子<pre id="6ee3c016-c417-4d14-82cb-103cac08fa7b" class="code code-wrap"><code>let obj4 = {
  identity: &quot;My Object&quot;,
  getIdentity() {
      return this.identity;
  },
};
console.log(obj4.getIdentity()); // My Object
console.log((obj4.getIdentity)()); // My Object
console.log((obj4.getIdentity = obj4.getIdentity)()); // The Global Object</code></pre><ul id="ed2c70e5-8e30-4f87-b430-157f7450bfe0" class="bulleted-list"><li style="list-style-type:circle"><code>obj4.getIdentity()</code> 正常调用，<code>this</code> 运行时绑定<code>obj4</code> 所以打印<code>obj4.identity</code></li></ul><ul id="f2054a54-06a5-4372-a253-f8b60034ae9a" class="bulleted-list"><li style="list-style-type:circle"><code>(obj4.getIdentity)()</code> 调用时将方法放在括号中，虽然加了括号之后就好像是对一个函数的直接引用，但<code>this</code> 值仍然没有变，因为按照规范<code>(obj4.getIdentity)</code> 和<code>obj4.getIdentity</code> 是相等的</li></ul><ul id="016bf16f-552b-41aa-93a1-827ac4ac4f3d" class="bulleted-list"><li style="list-style-type:circle"><code>(obj4.getIdentity = obj4.getIdentity)()</code> 这一次是执行了一次赋值，再调用赋值后的结果，因为赋值表达式的值是函数本身，<code>this</code> 值不再与任何对象绑定，默认是全局对象，所以打印<code>The Global Object</code></li></ul></li></ul><h1 id="5f52960f-5722-4e45-8050-bebf119cc63b" class="">14.3 内存泄漏（Memory Leaks）</h1><ul id="af9da709-a0e7-442b-8711-19ee2824e730" class="bulleted-list"><li style="list-style-type:disc">在第4章的内存管理节中有关于<a href="../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%89%E5%88%A9%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E5%86%99%E6%B3%95.html">3. 内存泄漏</a> 中介绍过内存泄漏：<div><ul id="c091c264-1f9b-426b-add5-4aed364caebb" class="bulleted-list"><li style="list-style-type:disc">内存泄漏通常指在<strong>内存有限</strong>的设备上，存储着一些<strong>不使用的变量值</strong>，但这些变量值因为代码写法的问题<strong>一直保留在内存中</strong>无法被垃圾回收程序回收，一旦这些变量值过多，程序运行占用的内存变少，如果分配给程序的内存无法满足程序运行条件，就会导致内存泄漏，而那些无用的变量值就是导致内存泄漏的原因之一</li></ul></div><div><h3 id="577042fa-1e46-4306-aca4-a9685ae5d308" class="">JavaScript闭包</h3><pre id="785be22c-6ed3-4f2d-ac27-5436352854a2" class="code"><code>let outer = function() {
	let name = &quot;function&quot;;
	return function () {
		return name;
	}
}</code></pre><ul id="3748e604-e502-4e90-b462-8e2ca1f947a9" class="bulleted-list"><li style="list-style-type:disc">调用<code>outer()</code> 会导致分配给name的内存被泄漏</li></ul><ul id="ed4abd3d-e026-43c1-aec1-85f37541ae87" class="bulleted-list"><li style="list-style-type:disc">以上代码之后后会创建一个闭包，只要outer调用返回的函数存在，垃圾回收程序就不能清理name，因为闭包一直引用name</li></ul><ul id="7d8634eb-cd77-4677-9dea-f0b68d2843c8" class="bulleted-list"><li style="list-style-type:disc">假设name的内容很大，那就会造成问题</li></ul></div></li></ul><ul id="2691e83c-b2d2-4055-9ff6-2ae816693aad" class="bulleted-list"><li style="list-style-type:disc">在第4章的<a href="../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/3%201-2%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html"><span class="icon">🏠</span>3.1-2 垃圾回收的实现方式</a> 中讨论过<a href="../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/3%201-2%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html">使用引用计数的浏览器版本</a> <ul id="a3488a54-b9fe-4853-a676-8b34f134e4da" class="bulleted-list"><li style="list-style-type:circle">由于IE在IE9之前对JScript对象和COM【C++实现的组件对象模型（COM，Component Object Model）】对象使用不同的垃圾回收机制（前者使用标记清理，后者使用引用计数）</li></ul><ul id="07d9fea8-e1f2-415f-99a5-dc2a65d08730" class="bulleted-list"><li style="list-style-type:circle">所以闭包在这些旧版本的IE可能会导致问题，例如把HTML元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁<pre id="e877e1d6-aa24-4cce-b039-649d2cebfda3" class="code code-wrap"><code>function assignHandler() {
  let element = document.getElementById(&quot;someElement&quot;);
  element.onclick = () =&gt; console.log(element.id);
}</code></pre><ul id="5551b151-1b32-45b6-996f-969f8764d603" class="bulleted-list"><li style="list-style-type:square">上述代码创建了一个闭包，即<code>element</code> 元素的<strong>事件处理程序</strong>（<strong>event handler</strong>）</li></ul><ul id="f8d20138-2b3a-4185-b13a-ab31d1c3456c" class="bulleted-list"><li style="list-style-type:square">这个事件处理程序又创建了一个循环引用，匿名箭头函数又引用<code>element</code> 导致创建了一个循环引用（circular reference）</li></ul><ul id="c5b654e8-34f3-4f59-a01f-8892edac7f48" class="bulleted-list"><li style="list-style-type:square">因为匿名箭头函数（的执行上下文作用域链）引用着<code>assignHandler()</code> 的活动对象，阻止对<code>element</code> 的引用计数归零</li></ul><ul id="ca78edff-641c-4262-9e02-ccda71c42d79" class="bulleted-list"><li style="list-style-type:square">只要这个匿名箭头函数存在，<code>element</code> 的引用计数至少为1，即内部不会<strong>被回收</strong>（<strong>reclaimed</strong>）</li></ul></li></ul></li></ul><ul id="ef93b2e4-0d8d-4fa7-a656-1710341724b2" class="bulleted-list"><li style="list-style-type:disc">解决这种问题的方式就是<a href="../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/3%201-2%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html">切断原生JavaScript对象和DOM元素之间的连接</a> 以及清空活动对象中无用的变量<pre id="cd7476e9-753b-4768-b3a2-42c84a1234bd" class="code code-wrap"><code>function assignHanlder() {
  let element = document.getElementById(&quot;someElement&quot;);
  let id = element.id;
  element.onclick = () =&gt; console.log(id);
  element = null;
}</code></pre><ul id="fe257e6a-243b-48a8-817f-c01034129b5c" class="bulleted-list"><li style="list-style-type:circle">闭包修改为引用一个保存着<code>element.id</code> 的变量<code>id</code> ，从而消除循环引用</li></ul><ul id="9135a810-4d77-4f83-affe-e340d33e13b2" class="bulleted-list"><li style="list-style-type:circle">因为闭包还是会引用包含函数的活动对象，这个活动对象中包含已经不再闭包中引用的<code>element</code> ，因此必须把<code>element</code> 设置为<code>null</code> </li></ul><p id="6aa82ab8-4fbe-4f3a-8e49-cf9db43efc51" class="">
</p></li></ul></div></div><p id="1294d54a-b807-49ee-9a65-6fdc7a9214b9" class="">
</p></div></article></body></html>