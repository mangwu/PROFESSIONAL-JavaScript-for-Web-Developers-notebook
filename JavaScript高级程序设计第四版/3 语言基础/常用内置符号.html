<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>常用内置符号</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style><link rel="stylesheet" href="../../style.css"></head><body><article id="20d09a96-5d28-44c8-86bf-494160a778c5" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/met_gerome_1890.jpg" style="object-position:center 70%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🪐</span></div><h1 class="page-title">常用内置符号</h1></header><div class="page-body"><div id="b2287b06-4ef1-4c39-a511-a123076db0d4" class="column-list"><div id="140d86f3-0019-4c8a-8d29-b81f1409125c" style="width:25%" class="column"><nav id="914bb737-76e0-4634-9caa-d9ccf675fbc2" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d6d134b0-2d3b-46bb-87e5-53d202bec1ea">1.<strong>Symbol.asyncIterator</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e090bf1b-487a-4ea9-a2b1-218f5673fdc5">2. Symbol.hasInstance</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5eefb0db-9747-4c5c-ab60-4bc355a6d61a">3. Symbol.isConcatSpreadable</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7fc6d587-f089-4db7-9c0b-352b39600427">4.Symbol.iterator</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c84229f5-56f1-44f6-bbfb-2d0312fa6437">5.Symbol.match</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b2971ee4-303a-4d63-85a2-b3f88d4be544">6.Symbol.replace</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#eec9898a-3d3a-418f-9b3d-63622dbd1d3e">7.Symbol.search</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d144472a-c88b-42ff-b2eb-70f77279a66c">8.Symbol.species</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dfe5571d-32c6-4f87-855b-9cd651d77eb7">9.Symbol.split</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1f8c8b64-6641-4f94-99e1-240da4880d26">10.Symbol.toPrimitive</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4e7f2afa-fcdf-4cd2-851e-678f09eaab63">11.Symbol.toStringTag</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#313e269f-bd4c-4cd2-b32b-4ea9db6d196e">描述</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b055107a-6bc6-4d89-9d23-2f8b7475a2d1">原理</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1b40c8bc-e2a0-4027-8d13-9f3df580df3b">12.Symbol.unscopables</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#41521b17-66bc-4c13-85e5-475a201d3b67">描述</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#dee1206a-b886-42f1-8ee1-fcbac56351da">with语句</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#238c3cc3-f62f-4fed-9890-840644ff1582">语法</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#c79e7ccc-0355-471c-8b02-a89e1e979047">作用</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#b5aa35e0-d651-45d8-bfa1-e4512538d4cb">局限性</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#72286073-d92e-45fb-be5f-875554dcc96d">Symbol.unscopables与with</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cd46e243-1c38-48ce-b44b-c67266b7a597">解绑</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6fe1cd93-8f10-43bb-a567-352a9f0c7ad9">使用</a></div></nav><p id="cce942aa-2ecc-4fad-8bb5-974172f3d326" class="">
</p></div><div id="ba80d611-7f84-4166-82f7-0c3f682e9438" style="width:75%" class="column"><h2 id="d6d134b0-2d3b-46bb-87e5-53d202bec1ea" class="block-color-orange_background">1.<strong>Symbol.asyncIterator</strong></h2><ol type="1" id="0276b0f0-8bd7-4d84-897d-6811325e29b7" class="numbered-list" start="1"><li>这个符号表示实现<strong>异步迭代器API</strong>函数</li></ol><ol type="1" id="4e53cf4f-75bc-487e-86db-5ae1465b7a68" class="numbered-list" start="2"><li>使用时，这个符号表示一个符号属性返回“一个方法，该方法返回默认的AsyncIterator。由<strong>for-await-of</strong>语句使用”</li></ol><ul id="55039dd2-949e-4e86-8561-39b0685e4823" class="bulleted-list"><li style="list-style-type:disc">异步迭代原理<ul id="556fe0af-d8b3-47da-b8cd-f02d8dbdaca3" class="bulleted-list"><li style="list-style-type:circle">使用for await of循环 调用定义了@@asyncIterator属性的对象</li></ul><ul id="27642a87-e9b9-4c45-b6bb-81abaf4d939b" class="bulleted-list"><li style="list-style-type:circle">循环时，会调用以@@sayncIterator为键的函数，这个函数会<strong>返回一个实现迭代器API</strong>的对象</li></ul><ul id="d62f8f2a-dd9d-46d8-9dee-7a5a18912814" class="bulleted-list"><li style="list-style-type:circle">实现该迭代器API的对象称为<code>AsyncGenerator</code>（生成器） ,可以通过在对象中定义异步生成器函数来实现</li></ul><ul id="96525f73-4d8a-4499-a208-bd480b7fb7ee" class="bulleted-list"><li style="list-style-type:circle">而生成器函数的定义可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">MDN_function*</a><pre id="9b3008e9-da76-4884-827e-3fb31d474f3f" class="code"><code>// 异步迭代器属性
class Foo {
  /**
   * @description 定义异步迭代器的生成器
   */
  async *[Symbol.asyncIterator]() {}
}
let foo = new Foo();
console.log(foo[Symbol.asyncIterator]);
// [AsyncGeneratorFunction: [Symbol.asyncIterator]]</code></pre><p id="f7191ee9-081e-474f-ab96-506c3a0084be" class="">⇒ 一个异步生成器函数</p><p id="8a04a134-2b00-45f2-b4cc-326d21fc0350" class="">⇒ 生成器函数被调用时会返回这个生成器的迭代器对象</p></li></ul></li></ul></div></div><ul id="6f3fc164-101c-4dce-a162-58e0d0b6547f" class="bulleted-list"><li style="list-style-type:disc">@@asyncIterator函数调用生成的迭代器对象通过<strong>next()方法陆续返回Promise实例</strong>，从而实现异步循环迭代</li></ul><ul id="6740dc7e-ae3c-43f8-a40d-ea06e5d5512e" class="bulleted-list"><li style="list-style-type:disc">可以通过显示next()方法返回，也可以<strong>隐式的通过异步生成器函数</strong>返回<pre id="21283f7a-ca21-408a-b7a1-7dbb1a4eb5d7" class="code"><code>/**
 * @description 一个被遍历的从0到N的迭代器类
 * @class IteratorFromZeroToN
 */
class IteratorFromZeroToN {
  constructor(max) {
    this.max = max;
    this.asyncId = 0;
  }
  /**
   * @generator asyncIterator 异步生成器
   */
  async *[Symbol.asyncIterator]() {
    while (this.asyncId &lt;= this.max) {
      yield new Promise((resolve) =&gt; resolve(this.asyncId++));
    }
  }
}
async function asyncCount() {
  let zeroToFive = new IteratorFromZeroToN(5);
  for await (const x of zeroToFive) {
    console.log(x);
  }
}
asyncCount();
console.log(&quot;非异步执行语句先于异步执行语句执行&quot;);
// 结果如下
非异步执行语句可能先于异步执行语句执行
0
1
2
3
4
5</code></pre><p id="326c093c-f642-4313-9960-6f60006db447" class="">⇒ 定义了一个使用异步迭代器属性，值为一个异步生成器的迭代器类</p><p id="0d59604c-760d-4492-b3a0-7ea3818ee9af" class="">⇒ 使用for await of语句异步遍历类实例，它会异步调用异步迭代符号属性中定义的生成器函数，获取异步迭代器，然后异步执行yield语句</p><p id="a80120f2-9a36-477e-90fb-4ee01f5c0de6" class="">⇒ 异步迭代器执行后于非异步语句</p><pre id="2a86c385-3e93-46d2-8d2a-3214635ee0b0" class="code"><code>let zeroToOne = new IteratorFromZeroToN(1);
console.log(
  zeroToOne[Symbol.asyncIterator]()
    .next()
    .then((value) =&gt; console.log(value))
    .catch((err) =&gt; {
      console.log(err, &quot;异步迭代器执行next()失败&quot;);
    })
);
// 打印
Promise { &lt;pending&gt; }
{ value: 0, done: false }</code></pre><p id="eb50801c-c044-4a58-a6b0-0e3650c4edd5" class="">⇒ 使用了显示调用迭代器对象的next()方法获取迭代器的值</p><p id="7ca06625-7d57-4abb-b9fa-e3a3145606a8" class="">⇒ 通过@@asyncIterator属性获取对象实例中的生成器对象</p><p id="78947c3a-d0f7-49d1-9d70-8b24a98c9e30" class="">⇒ 然后<strong>调用生成器获取对应的迭代器对象</strong></p><p id="066069f5-1ffe-4859-b0d5-8774c622bcfd" class="">⇒ 迭代器对象通过显示的调用next()会返回异步的Promise对象</p><p id="c838e2be-a1c3-4349-8236-113ba7932fc1" class="">⇒ 然后使用.then()  .catch获取相关的值和处理错误情况</p><p id="0981c066-897e-4b92-87b1-9599e9ba2616" class="">⇒ 其实使用next()函数返回的是一个对象<code>{value: x, done: boolean}</code> value表示迭代器这一次的值，done表示迭代器是否迭代完毕</p></li></ul><ul id="9a99b36d-4d74-44a4-92a4-1d6da73dee6d" class="bulleted-list"><li style="list-style-type:disc">注意@@asyncIterator是ES2018规范定义的，只有比较新的浏览器支持</li></ul><h2 id="e090bf1b-487a-4ea9-a2b1-218f5673fdc5" class="block-color-yellow_background">2. Symbol.hasInstance</h2><ol type="1" id="780d2310-edfa-4e62-8df6-cdb6fa5b5339" class="numbered-list" start="1"><li>ECMAScript 规划：该符号作为对象属性表示“一个方法、该方法决定一个<strong>构造器对象</strong>是否认可一个对象是它的实例，由instanceof操作符使用”</li></ol><ol type="1" id="d2001878-2947-49db-81cd-2137d3cab4e0" class="numbered-list" start="2"><li><code>instanceof</code>的使用：用于判断一个<strong>对象实例的原型链</strong>上是否有原型<pre id="10cc295c-e4db-4c39-83b5-fe3aa2ed1ff7" class="code"><code>// instanceof 判断对象实例的原型链上是否有对应类或方法的原型
function Foo() {
  this.sum = function (x, y) {
    return x + y;
  };
}
// Foo实例
const foo = new Foo();
console.log(foo.sum(1, 2));
console.log(foo instanceof Foo); // true

class Bar {}
const bar = new Bar();
console.log(bar instanceof Bar); //true</code></pre></li></ol><ol type="a" id="e8a2d98c-a6d8-445c-beaa-5e0db0b5986f" class="numbered-list" start="3"><li>@@hasInstance函数原理<ol type="i" id="4c229f5a-9833-41e5-93ee-9fb9a7ae3a3e" class="numbered-list" start="1"><li><strong>默认</strong>所有函数和类上都定义了Symbol.hasInstance符号属性，它被定义在Function的原型上</li></ol><ol type="i" id="d3760f14-aff8-4207-b318-e90865cd2cae" class="numbered-list" start="2"><li>而<code>instanceof</code> 操作符就是使用了类或者函数中的Symbol.hasInstance函数来确定对象实例是否是其构造实例</li></ol><ol type="i" id="64ebb0a1-59a4-4139-b009-8fd4685b0a60" class="numbered-list" start="3"><li>可以通过类或者方法调用符号属性hasInstance对应的<strong>静态方法，以实例为参数，</strong>即可以得知该实例是否由该方法或类构造<pre id="ad9d395b-3d79-4a0b-b620-f88e090052cb" class="code"><code>// ES6 定义的方法和类都默认有符号属性@@hasInstance
let f = new Foo();
console.log(Foo[Symbol.hasInstance](f)); // true

let b = new Bar();
console.log(Bar[Symbol.hasInstance](b)); // true</code></pre></li></ol></li></ol><ol type="a" id="31af6692-3f13-4224-b501-c2e78fa79c7f" class="numbered-list" start="4"><li>覆写@@hasInstance属性方法<ol type="i" id="ee93eead-6508-4e1d-ad98-8cf30a06a87a" class="numbered-list" start="1"><li>因为该符号属性定义在Function的原型上，所以instanceof操作符可以在原型链上找到该符号属性</li></ol><ol type="i" id="855a5f0e-80e2-404a-ae0b-7ff715c37c6f" class="numbered-list" start="2"><li>原型链是可以被继承的，所以可以在继承类上通过<strong>静态方法覆写</strong><pre id="f3d19c78-fadc-4970-b182-2aba66b77639" class="code"><code>// 覆写静态方法 @@hasInstance
class Baz extends Bar {
  static [Symbol.hasInstance]() {
    return false;
  }
}
const baz = new Baz();
console.log(Bar[Symbol.hasInstance](baz)); // true
console.log(Baz[Symbol.hasInstance](bar)); // false
console.log(Baz[Symbol.hasInstance](baz)); // false</code></pre><p id="fa965a20-e957-498a-b200-e6a51b6f20e2" class="">= Baz类中的hasInstance符号属性静态方法始终返回false</p><p id="f64deb1c-e137-4632-b97b-423e2e60efb4" class="">⇒ Bar类调用的hasInstance对子类的实例仍然有效，所以返回true</p><p id="585aacc8-7810-4f7e-8be4-275154dcf6be" class="">⇒ 使用instanceof调用Baz和baz有同样的返回结果</p></li></ol></li></ol><h2 id="5eefb0db-9747-4c5c-ab60-4bc355a6d61a" class="block-color-blue_background">3. Symbol.isConcatSpreadable</h2><ol type="1" id="ea93bfe7-adb3-4ff2-ab8c-8d056d066727" class="numbered-list" start="1"><li>规范：<ol type="a" id="4d51b0d0-8210-4e57-b38c-ecc5fb5104e5" class="numbered-list" start="1"><li>描述：ECMAScript表示，这个符号属性表示”一个布尔值，<strong>如果是true，则意味着对象应该用Array.prototype.concat()打平其数组元素</strong>“</li></ol><ol type="a" id="6c6f2d1b-630a-437d-b877-71af04a0360a" class="numbered-list" start="2"><li>Array.prototype.concat()方法会根据接受到的对象类型选择如何将一个<strong>类数组对象</strong>拼接<ol type="i" id="2e0505dc-105a-476d-957a-2415efdcb890" class="numbered-list" start="1"><li>concat()通常有两种拼接方式，一种是将整个对象或其他类型变量作为<strong>数组元素</strong>追加到数组末尾</li></ol><ol type="i" id="f142c15e-1d8d-4436-b24e-a0bf6bb90a1f" class="numbered-list" start="2"><li>另一种拼接方式，是将<strong>类数组对象</strong>中的每个元素一个个追加到数组末尾<pre id="99cc7572-971d-441c-9b96-742f1ce27239" class="code"><code>// 默认concat的两种拼接方式
const a = [1, 2];
const d = { 3: 4 };
const e = [4,5];
// 直接将对象作为元素追加最后
console.log(a.concat(d));
// 数组对象中的元素
console.log(a.concat(e));</code></pre></li></ol></li></ol><ol type="a" id="aa308f5a-969d-4bc4-bd30-5684b9708082" class="numbered-list" start="3"><li>通过修改被添加到末尾的数组对象中的@@isConcatSpreadable属性（默认未定义）的布尔值，可以做到对类数组对象被添加时的添加行为的控制<ol type="i" id="ac5cc7a0-dfa4-4554-8155-3fbfba20a615" class="numbered-list" start="1"><li>当@@isConcatSpreadable设置为false时，数组对象整个会被追加到数组末尾（默认为打平到数组末尾）<pre id="bc63c7ac-bb6d-4a74-8e2a-b4a7d43f69cb" class="code"><code>// 修改@@isConcatSpreadable
const initial = [&quot;foo&quot;];
const array = [&quot;bar&quot;];
console.log(array[Symbol.isConcatSpreadable]);
// 默认未定义，使用默认方式进行数组拼接
console.log(initial.concat(array)); // [&quot;foo&quot;, &quot;bar&quot;];

// 设置为false，不可打平拼接
array[Symbol.isConcatSpreadable] = false;
console.log(initial.concat(array));
// 下方是打印结果
undefined
[ &#x27;foo&#x27;, &#x27;bar&#x27; ]
[ &#x27;foo&#x27;, [ &#x27;bar&#x27;, [Symbol(Symbol.isConcatSpreadable)]: false ] ]</code></pre></li></ol><ol type="i" id="42cd9053-eca8-41fd-8a3a-3fa1233fa022" class="numbered-list" start="2"><li>当@@isConcatSpreadable设置为true时，<strong>类数组对象</strong>会被打平拼接到数组中（默认所有对象会作为一个元素被整个追加到数组末尾）<pre id="19fa9d64-bb8a-4b8a-9bce-c7f5f097d88c" class="code"><code>// 类数组对象会被打平入数组
const arrayLikeObject = { length: 1, 0: &quot;baz&quot; };
console.log(arrayLikeObject[Symbol.isConcatSpreadable]);
console.log(initial.concat(arrayLikeObject)); // 整个拼接
arrayLikeObject[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(arrayLikeObject));
// 结果
undefined
[ &#x27;foo&#x27;, { &#x27;0&#x27;: &#x27;baz&#x27;, length: 1 } ]
[ &#x27;foo&#x27;, &#x27;baz&#x27; ]</code></pre><p id="bffe173a-be47-494c-b48e-8818d1836001" class="">⇒ 数组对象是以从0开始的数字为索引属性，最后以length为属性表示数字长度的对象</p><p id="b8df3ed5-8032-4ca5-bdbe-7e795f44e61b" class="">⇒ 通过<code>{}</code> 构建一个类数组对象使用上述方式即可</p><p id="9cf27434-1115-4917-8c30-7697083ac110" class="">⇒ 设置isConcatSpreadable为true可以将类数组对象平打入</p></li></ol><ol type="i" id="8f5a9339-47ec-4b4e-a225-e5b7425b21f1" class="numbered-list" start="3"><li>对于普通对象（非数组对象），未设置isConcatSpreadabel符号属性默认打入整个对象，设置为true时，因为普通对象无法被打平入数组，所以被忽略（设置为false时仍然整个对象作为元素拼接入）<pre id="edcbe18b-5fd1-45cb-b4fe-c49eb3306f1a" class="code"><code>// 普通对象设置为打平会被忽略
const obj = { a: 1 };
console.log(obj[Symbol.isConcatSpreadable]);
console.log(initial.concat(obj)); // 整个接入
obj[Symbol.isConcatSpreadable] = true;
console.log(initial.concat(obj)); // 被忽略

// 打印结果
undefined
[ &#x27;foo&#x27;, { a: 1 } ]
[ &#x27;foo&#x27; ]</code></pre></li></ol></li></ol></li></ol><h2 id="7fc6d587-f089-4db7-9c0b-352b39600427" class="block-color-purple_background">4.Symbol.iterator</h2><ul id="3492846c-ce58-4eda-807b-e8026610a483" class="bulleted-list"><li style="list-style-type:disc">Symbol.iterator符号属性：<div><ul id="0df8a417-58dc-454e-b6db-2437a1f6419a" class="bulleted-list"><li style="list-style-type:disc">描述：该符号属性表示“一个方法，该方法返回<strong>对象默认的迭代器</strong>，由for of语句使用”。</li></ul></div><ul id="0e2bbcea-937f-4be6-884b-5993c996e544" class="bulleted-list"><li style="list-style-type:circle">或者说，该符号属性定义的实现迭代器API的函数（生成器）</li></ul><ul id="48dc0835-5768-44a7-ad6e-58d7811e2d63" class="bulleted-list"><li style="list-style-type:circle">原理：<ol type="i" id="50705cef-43be-413d-aed3-e63cd3d1f05a" class="numbered-list" start="1"><li>for of循环会利用符号属性定义的实现迭代器API的函数执行迭代操作</li></ol><ol type="i" id="1d5c8c7f-dd45-4925-874b-0d733b521037" class="numbered-list" start="2"><li>循环时，for of调用对象以Symbol.iterator为键的函数</li></ol><ol type="i" id="a212e38a-32fa-4e75-8399-ebd95c037382" class="numbered-list" start="3"><li>这个符号属性返回一个实现迭代器的API对象，即生成器函数</li></ol><ol type="i" id="5ad065b5-019b-4268-823e-e54d1ee6b696" class="numbered-list" start="4"><li>该生成器函数被调用会返回该对象的<strong>迭代器对象</strong></li></ol><ol type="i" id="fd63b0b3-0988-497d-b2cb-ed8b783ddbf9" class="numbered-list" start="5"><li>for of就利用迭代器对象进行循环遍历<pre id="82d711cd-8822-406e-a8af-9f8a80f25a9b" class="code"><code>class Foo {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
  }
}
const foo = new Foo();

console.log(foo[Symbol.iterator]);

for (const i of foo) {
  console.log(i);
}
// 打印结果
[GeneratorFunction: [Symbol.iterator]]
1
2</code></pre></li></ol></li></ul></li></ul><ul id="797e998f-5eab-4301-81a1-edceb59c95dc" class="bulleted-list"><li style="list-style-type:disc">使用方法<ul id="97b3204a-95da-40f5-9e9b-4bae743d7410" class="bulleted-list"><li style="list-style-type:circle">既可以通过for of遍历对象的迭代器对象</li></ul><ul id="87507dbe-dcf4-4166-90f0-f027b7b0b51c" class="bulleted-list"><li style="list-style-type:circle">又可以主动通过@@iterator属性获取对象的生成器函数，然后调用获得迭代器对象，再调用迭代器对象的next()方法显式的返回迭代器中的元素<pre id="e28aacad-2753-490f-a79a-01226ee7f1a3" class="code"><code>// 显式调用
class Bar {
  constructor(max) {
    this.idx = 0;
    this.max = max;
  }
  *[Symbol.iterator]() {
    while (this.idx &lt; this.max) {
      yield this.idx++;
    }
  }
}
const bar = new Bar(3);
console.log(bar[Symbol.iterator]().next());
console.log(bar[Symbol.iterator]().next());
console.log(bar[Symbol.iterator]().next());
console.log(bar[Symbol.iterator]().next());
// 打印结果
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }</code></pre></li></ul></li></ul><h1 id="c84229f5-56f1-44f6-bbfb-2d0312fa6437" class="block-color-teal_background">5.Symbol.match</h1><ul id="bfe0a233-1565-4a3c-9103-b31346d9f75e" class="bulleted-list"><li style="list-style-type:disc">Symbol.match符号属性：<ul id="54640e54-fa26-40cf-9ff4-46203c38c288" class="bulleted-list"><li style="list-style-type:circle">描述：该符号属性表示“一个正则表达式方法，该方法用正则表达式取匹配字符串，由String.prototype.match()方法使用”。</li></ul><ul id="68cfe28a-834e-46a5-97ab-af9161e596e4" class="bulleted-list"><li style="list-style-type:circle">String.prototype.match()方法会使用以Symbol.match为键的函数来对正则表达式求值</li></ul><ul id="a5618a5d-9705-4a8e-810b-52c9e0106f28" class="bulleted-list"><li style="list-style-type:circle"><strong>正则表达式的原型上默认有这个函数的定义，</strong>所以所有正则表达式实例默认是这个String方法的有效参数</li></ul><ul id="c264a9ad-3904-4018-b750-f325957890e3" class="bulleted-list"><li style="list-style-type:circle">原理：<ol type="i" id="fa295292-8fcf-47b1-bf99-706557cc3003" class="numbered-list" start="1"><li>任何字符串上都有<code>match()</code> 这个方法，而match的参数应该是<strong>正则表达式</strong>或<strong>能构造正则表达式的参数</strong></li></ol><ol type="i" id="70ead5a1-1b72-4822-8569-779f68e87d02" class="numbered-list" start="2"><li>调用字符串的match()方法，match就会通过传入的参数<strong>先构造一个正则表达式实例</strong></li></ol><ol type="i" id="564a5732-c7aa-4af7-a44e-059e402b393f" class="numbered-list" start="3"><li>再获取正则表达式实例的<strong>Symbol.match属性值，</strong>获取到的属性值是一个能对字符串进行正则匹配的函数</li></ol><ol type="i" id="c9e11c0f-ea04-45fe-b93d-a25288ae5cd8" class="numbered-list" start="4"><li>字符串调用该<strong>符号属性值函数</strong>进行字符匹配操作，获得匹配到的字符<pre id="74092b3d-5c0e-4495-a42e-44b4b7598d17" class="code"><code>// 所有正则表达式实例上都有match符号
console.log(RegExp.prototype[Symbol.match]);
console.log(&quot;foobar&quot;.match(/bar/));
// 打印
[Function: [Symbol.match]]
[ &#x27;bar&#x27;, index: 3, input: &#x27;foobar&#x27;, groups: undefined ]</code></pre></li></ol></li></ul><ul id="59335bd9-ecf2-4932-b2e8-4d55e34cf18b" class="bulleted-list"><li style="list-style-type:circle">使用方式：<ul id="c1b436b6-1d32-476d-976a-3aadc05e727f" class="bulleted-list"><li style="list-style-type:square">因为传入match函数的参数会被构造成一个正则表达式实例，那么传入一个修改过Symbol.match符号属性值函数的类或者类对象实例就会调用Symbol.match符号属性方法</li></ul><ul id="02bd0ab7-bae5-46c0-952f-b7c51d455a87" class="bulleted-list"><li style="list-style-type:square">注意：Symbol.match符号属性方法以target为参数（调用字符串）<pre id="718991a4-12c6-4d85-95da-c640e58fc993" class="code"><code>// 修改@@match属性函数
class FooMatch {
  [Symbol.match](target) {
    // target是通过match()调用参数中的符号属性的字符串
    return target.includes(&quot;foo&quot;);
  }
  static [Symbol.match](target) {
    return target.includes(&quot;foo&quot;);
  }
}
const fm = new FooMatch();
console.log(&quot;fooBar&quot;.match(FooMatch)); 
console.log(&quot;barbaz&quot;.match(fm));
// 大于结果
true
false</code></pre><p id="41eac02e-c421-4247-b75d-b3d172b64650" class="">⇒ 既可以写成<strong>静态方法</strong>，也可以写成<strong>对象方法，</strong>在调用时传入实例或者类即可</p></li></ul><ul id="0bba76e0-f6cc-40da-85f0-daa8fae6018b" class="bulleted-list"><li style="list-style-type:square">除此之外，可以写一个字符串匹配类（StringMatcher）用以在创建对象时自定义匹配字符和匹配（Symbol.match）方法<pre id="bbf8308b-ca00-43f4-8347-9332f80fd887" class="code"><code>// 自定义匹配字符和匹配方法
class StringMatcher {
  constructor(str) {
    this.str = str;
  }
  [Symbol.match](target) {
    // target是通过match()调用参数中的符号属性的字符串
    return target.includes(this.str);
  }
}

const sm = new StringMatcher(&quot;Bar&quot;);
console.log(&quot;fooBar&quot;.match(sm));</code></pre><p id="7e455d38-b8fc-48b7-81fc-0ebe9fe4177e" class="">⇒ 可以自定义匹配一个传入的任意字符</p></li></ul></li></ul></li></ul><h1 id="b2971ee4-303a-4d63-85a2-b3f88d4be544" class="block-color-orange_background">6.Symbol.replace</h1><ul id="aeff0bcf-a64c-4711-bf35-20a88dbafb7b" class="bulleted-list"><li style="list-style-type:disc">描述：<ul id="07d5d7a3-c37f-4eb6-87ed-c69d74bc7a27" class="bulleted-list"><li style="list-style-type:circle">ECMAScript规范表示，这个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由String.prototype.replace()方法使用”</li></ul><ul id="b449f92b-3458-4f1d-87b9-cedaa98b13d1" class="bulleted-list"><li style="list-style-type:circle">字符串方法replace会使用以Symbol.replace为键的函数来对正则表达式求值</li></ul><ul id="38d5e26a-0c3a-44b0-916a-f67a0c60a34e" class="bulleted-list"><li style="list-style-type:circle">所有<strong>正则表达式的原型</strong>上默认有<strong>Symbol.replace符号属性定义的替换函数</strong>，所以任何正则实例都是字符串replace方法的有效参数</li></ul><pre id="7242cd37-48fa-4890-b5fa-f61f71581341" class="code code-wrap"><code>// 正则表达式原型上都有@@replace符号属性定义的函数
console.log(RegExp.prototype[Symbol.replace]);
console.log(&quot;foovarbaz&quot;.replace(&quot;var&quot;, &quot;bar&quot;));
// 打印结果
[Function: [Symbol.replace]]
foobarbaz</code></pre></li></ul><ul id="bba91891-137e-4512-a8bc-c3c32cddc2f9" class="bulleted-list"><li style="list-style-type:disc">原理<ul id="c141c3a4-e26b-4165-96d3-ed356a6b3770" class="bulleted-list"><li style="list-style-type:circle">字符串原型上的replace方法会将一个参数转化为RegExp对象实例</li></ul><ul id="558fb40d-6dc2-4f88-aa2c-e43dda293a67" class="bulleted-list"><li style="list-style-type:circle">获得RegExp对象实例后，字符串replace方法就会调用该正则实例原型上的@@replace符号属性函数</li></ul><ul id="77d31287-e89e-471c-a1e2-a01a1a0c75f1" class="bulleted-list"><li style="list-style-type:circle">并将调用replace的<strong>字符串</strong>和<strong>替换的字符</strong>作为参数传递给该符号属性函数用于匹配替换，返回值没有限制<pre id="f0597b90-d4ec-480c-95fb-519b4919dbcf" class="code code-wrap"><code>/**
 * @description @@repalc符号属性函数
 * @param {String} target 调用字符串
 * @param {String} replacement 替换字符
 */
(static) [Symbol.replace](target, replacement) {
	....
}</code></pre></li></ul></li></ul><ul id="5428e27c-3055-49b1-885c-3e91edfde762" class="bulleted-list"><li style="list-style-type:disc">例子<ul id="9ae7c3d6-b978-4491-b002-bb00ad6bd727" class="bulleted-list"><li style="list-style-type:circle">知道字符串replace方法的原理后，可以自定义一个带有@@replace符号属性函数的类</li></ul><ul id="20993f04-46cc-4010-8775-54811f34a446" class="bulleted-list"><li style="list-style-type:circle">在调用字符串的replace方法时，第一个参数传入自定义的具有符号属性的类或者类实例</li></ul><ul id="d241a065-447c-4c51-9161-e3ea0cea7a9f" class="bulleted-list"><li style="list-style-type:circle">字符串replace方法就会调用该类或者实例的@@replace符号属性函数，同时传入相应参数<pre id="848aaf26-3223-4b6a-9014-64ceb1a18bbe" class="code code-wrap"><code>// 定义符号属性函数类
class ReplaceFoo {
  constructor(str) {
    this.str = str;
  }
  /**
   * @description 自定义Symbol.replace符号属性函数
   * @static 静态方法
   * @param {String} target 调用字符串
   * @param {String} replacement 替换字段
   * @returns {String}
   */
  static [Symbol.replace](target, replacement) {
    // 将所有foo字段替换为replacement字段
    return target.split(&quot;foo&quot;).join(replacement);
  }
  /**
   * @description 对象方法，自定义实例对象的Symbol.replace符号属性函数
   * @param {String} target 调用字符串
   * @param {String} replacement 替换字段
   * @returns {String}
   */
  [Symbol.replace](target, replacement) {
    // 将多有自定义字段替换为replacement字段
    return target.split(this.str).join(replacement);
  }
}
const replaceBar = new ReplaceFoo(&quot;Bar&quot;);
console.log(&quot;afoobfooc&quot;.replace(ReplaceFoo, &quot;$&quot;));
console.log(&quot;aBargoodBarmanBar&quot;.replace(replaceBar, &quot;#&quot;));
// 打印结果
a$b$c
a#good#man#</code></pre></li></ul></li></ul><h1 id="eec9898a-3d3a-418f-9b3d-63622dbd1d3e" class="block-color-yellow_background">7.Symbol.search</h1><ul id="5a53fef4-64b9-4a4b-83a0-2261350099e1" class="bulleted-list"><li style="list-style-type:disc">描述<ul id="dc432f3f-6985-46ac-9bc1-47930abd5897" class="bulleted-list"><li style="list-style-type:circle">ECMAScript规范定义，@@search符号属性“表示一个正在表达式方法，该方法返回字符串中匹配正则表达式的索引。由字符串方法String.prototype.search()方法使用”</li></ul><ul id="c3b95ed7-ca97-42a6-974d-deb2cf79fe00" class="bulleted-list"><li style="list-style-type:circle">字符串方法search会使用正则表达式原型中的Symbol.search符号属性函数</li></ul><ul id="b48c4e8e-c084-4923-931d-9ff60ddfb695" class="bulleted-list"><li style="list-style-type:circle">正则表达式原型上默认有该符号属性函数，因此所有正则表达式实例都是这个字符串search方法的有效参数<pre id="43411f8c-a5df-4103-aac3-6c59074ad85c" class="code code-wrap"><code>// 所有正则表达式的原型上都有Symbol.search符号属性
console.log(RegExp.prototype[Symbol.search]);
console.log(&quot;foobar&quot;.search(&quot;bar&quot;));
// 打印结果
[Function: [Symbol.search]]
3</code></pre></li></ul></li></ul><ul id="e1ac5acf-41e5-4aee-a29d-226ed409c301" class="bulleted-list"><li style="list-style-type:disc">原理<ul id="98eddd4e-5cae-427c-a82d-64e0901506fd" class="bulleted-list"><li style="list-style-type:circle">字符串方法search的参数会被转化为一个正则表达式对象</li></ul><ul id="385236d7-e347-4653-af9c-e18b42258953" class="bulleted-list"><li style="list-style-type:circle">字符串方法search调用正则表达式式对象的Symbol.search符号属性函数，将<strong>字符串本身</strong>传递给该符号属性函数</li></ul><ul id="dd53bec0-7c36-450b-b278-58353be41f99" class="bulleted-list"><li style="list-style-type:circle">@@search函数通过正则匹配获得第一个匹配到的字符，然后返回匹配到的头索引值</li></ul><ul id="4a0e2378-5d7d-4f08-b8c7-74dcd8a4175e" class="bulleted-list"><li style="list-style-type:circle">通过在类中自定义Symbol.search符号属性函数，就可以在传递字符串方法参数时使用<strong>自定义的类</strong>，从而调用自定义类中的符号属性函数<pre id="832a7ec1-d244-4295-8e92-7dbed0ab9258" class="code code-wrap"><code>class BarSearcher {
  constructor(str) {
    this.str = str;
  }
  static [Symbol.search](target) {
    return target.indexOf(&quot;bar&quot;);
  }
  [Symbol.search](target) {
    // 返回自定义的匹配索引
    return target.indexOf(this.str);
  }
}

const foosearch = new BarSearcher(&quot;foo&quot;);
console.log(&quot;afoobar&quot;.search(BarSearcher));
console.log(&quot;afoobar&quot;.search(foosearch));
// 打印结果
4
1</code></pre></li></ul></li></ul><h1 id="d144472a-c88b-42ff-b2eb-70f77279a66c" class="block-color-orange_background">8.Symbol.species</h1><ul id="e394bc68-a130-43f7-8aa5-bcbafbb366f2" class="bulleted-list"><li style="list-style-type:disc">描述<ul id="a37aecc7-9c53-4dc9-9793-3fef9ec76e91" class="bulleted-list"><li style="list-style-type:circle">根据ECMAScript规范，@@species符号属性表示“一个函数值，该函数作为<strong>创建派生对象</strong>的构造函数”</li></ul><ul id="cdbed7fe-df48-40c4-9cad-bd1ca569f401" class="bulleted-list"><li style="list-style-type:circle">Symbol.sepecies符号属性在<strong>内置类型（即JavaScript的7种数据类型和其他公共对象）</strong>中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法<ul id="a3a96b99-6382-4f60-9005-9ffe0bb27f29" class="bulleted-list"><li style="list-style-type:square">即对于JavaScript的内置类型的构造方法来说，其如何构造的（构造函数）是被隐藏的</li></ul><ul id="1db9b9d2-8fa6-497e-8bc0-fd772372ffbc" class="bulleted-list"><li style="list-style-type:square">通过Symbol.species符号属性可以在<strong>子类（继承内置类型）覆盖对象的默认构造函数</strong><pre id="97ebe8ac-cc03-494b-8fd1-65993857bde8" class="code"><code>class Baz extends Array {
	static get [Symbol.species] () {
		return Array;
	}
}</code></pre></li></ul></li></ul></li></ul><ul id="71346bab-4916-42bc-b000-d5e834b6e75f" class="bulleted-list"><li style="list-style-type:disc">注意<ul id="477068ca-65ca-4e92-ab97-a2f47f9bb084" class="bulleted-list"><li style="list-style-type:circle">在构造实例对象时，如果继承了内置对象，未修改覆盖修改构造函数，新实例的特性和和继承的一致，同时属于父类的构造实例</li></ul><ul id="79aef365-84a4-41b7-b4c9-8c7a1b24f738" class="bulleted-list"><li style="list-style-type:circle">而覆盖了内置对象的实例再使用了内置对象的方法后，原始类型可能会发生改变<pre id="89a3cfd3-5321-42f7-9344-f3da8563d138" class="code"><code>class Bar extends Array {}
class Baz extends Array {
  static get [Symbol.species]() {
    return Array;
  }
}

// 未覆盖Array的父类实例
let bar = new Bar();
console.log(bar instanceof Bar, bar);
console.log(bar instanceof Array);
bar = bar.concat(&quot;bar&quot;);
console.log(bar instanceof Bar, bar);
console.log(bar instanceof Array);
// 覆盖了Array的父类实例
let baz = new Baz();
console.log(baz instanceof Baz, baz);
console.log(baz instanceof Array);
baz = baz.concat(&quot;baz&quot;); // 返回一个数组对象，而不是Baz对象
console.log(baz instanceof Baz, baz);
console.log(baz instanceof Array);

// 打印
true Bar(0) []
true
true Bar(1) [ &#x27;bar&#x27; ]
true
true Baz(0) []
true
false [ &#x27;baz&#x27; ]   // 不再是Baz对象，而是自定义的Array
true</code></pre></li></ul></li></ul><h1 id="dfe5571d-32c6-4f87-855b-9cd651d77eb7" class="block-color-orange_background">9.Symbol.split</h1><ul id="d6e8c921-cf44-468b-aeb6-b1aee692f413" class="bulleted-list"><li style="list-style-type:disc">描述：<ul id="432b2714-dbaf-4dcf-a901-2b6681758175" class="bulleted-list"><li style="list-style-type:circle">ECMA规范：split符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串，由String.prototype.split()方法使用”。</li></ul><ul id="a779f470-cb3a-4314-809f-7e88d9645e15" class="bulleted-list"><li style="list-style-type:circle">字符串调用split方法，它会调用正则表达式（或者其他自定义的Symbol.split属性函数）实例的以Symbol.split为键的函数来对正则表达式求值</li></ul><ul id="8a1d78f2-e0ab-4a32-9bca-91cfb0e4d0aa" class="bulleted-list"><li style="list-style-type:circle">所有正则表达式原型上默认有这个函数定义<pre id="445e0f8a-8a86-49c2-a609-ee69143f5713" class="code"><code>console.log(RegExp.prototype[Symbol.split]);
// 一个符号属性函数
console.log(&#x27;foobarbaz&#x27;.split(/bar/));
// 调用/bar/构造的正则上的Symbol.split符号属性函数进行字符串拆分

// 结果
[Function: [Symbol.split]]
[ &#x27;foo&#x27;, &#x27;baz&#x27; ]</code></pre></li></ul></li></ul><ul id="d9d637b4-8eb2-4d70-92a7-9e6eace2101d" class="bulleted-list"><li style="list-style-type:disc">原理：<ul id="7170b6a5-95ac-484c-a0d9-c1fd6b36299d" class="bulleted-list"><li style="list-style-type:circle">通过字符串split方法传递一个正则表达式实例(或者转化成一个正则实例)，然后调用正则表达式实例中的Symbol.split符号属性函数即可完成对字符串的拆分</li></ul><ul id="822b2657-4f64-4007-b61f-a8e189f5b46d" class="bulleted-list"><li style="list-style-type:circle">这个方式让自定义split符号属性函数具有可行性，这就能改变split的行为特性</li></ul><ul id="751dc629-cb96-4ac1-bc73-41e70b513b2f" class="bulleted-list"><li style="list-style-type:circle">自定义一个具有split符号属性函数的类，取代默认对正则表达式求值的行为，让字符串split方法使用非正则表达式实例，从而修改split特性</li></ul><ul id="f38a4039-5768-4f1d-a1cd-100d0084dedc" class="bulleted-list"><li style="list-style-type:circle">注意，符号属性参数为调用的字符串本身<pre id="8ea320cf-6838-44f4-b9fb-176e3eb1d4b2" class="code"><code>// 自定义符号属性类
class FooSplitter {
  static [Symbol.split](target) {
    return target.split(&quot;foo&quot;);
  }
}
console.log(&quot;barfoobaz&quot;.split(FooSplitter));

class StringSplitter {
  constructor(str) {
    this.str = str;
  }
  [Symbol.split](target) {
    return target.split(this.str);
  }
}
console.log(&quot;abcd&quot;.split(new StringSplitter(&quot;&quot;)));

// 结果
[ &#x27;bar&#x27;, &#x27;baz&#x27; ]
[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</code></pre></li></ul></li></ul><h1 id="1f8c8b64-6641-4f94-99e1-240da4880d26" class="block-color-orange_background">10.Symbol.toPrimitive</h1><ul id="d913b269-d68e-432a-81a9-dccb6d655823" class="bulleted-list"><li style="list-style-type:disc">描述<ul id="c1b47dd4-d64c-479a-8340-07e59a6f0785" class="bulleted-list"><li style="list-style-type:circle">ECMAScript规范,这个符号作为一个属性表示”一个方法，该方法将对象转化为相应的原始值， 由ToPrimitive抽象操作使用“</li></ul><ul id="1039658c-419d-4d23-b08e-e28fa4d2ca0e" class="bulleted-list"><li style="list-style-type:circle">在JavaScript中有很多内置操作都会尝试<strong>强制将对象转化为原始值</strong>，这种原始值包括字符串、数值、和未指定的原始类型，如<ul id="236573ef-fec7-43a9-b9e9-dbbf5baa1689" class="bulleted-list"><li style="list-style-type:square">+：作为正号时，将其它类型强制转化为数字类型；作为<strong>加法运算符号</strong>时，又分为两种，一种是<strong>数字相加</strong>的<strong>双目加号操作符，</strong>一种是<strong>字符串连接的双面加号操作符</strong><ol type="1" id="76f156ba-5419-48c5-b295-a3e4f10fd290" class="numbered-list" start="1"><li>符号，可以将字符串或者其它类型强制转化为数字类型<pre id="45915410-d18e-47cc-8400-ff58ba28dadf" class="code code-wrap"><code>// 1. 符号
const date = new Date();
console.log(+date);

// 输出
1652865426375 // 数字</code></pre></li></ol><ol type="1" id="51675932-002d-4294-8744-3cd32e4e8c62" class="numbered-list" start="2"><li>双目加号操作符号，如果相加双方有一个是对象[非<code>Date</code>类型对象(Date对象使用“偏好数字”的算法)],则使用“无偏好”的算法，转化为两个操作数，如果这两个操作数中有字符串类型，就将起转化为字符串后进行连接，否则两个操作数都转成数字后相加<pre id="2eb38465-08c0-4c4f-87d3-100e704e9126" class="code code-wrap"><code>// 2. 对象
class Bar {
  constructor(data) {
    this.data = data;
  }
  toString() {
    return this.data;
  }
}
const bar1 = new Bar(1);
const bar2 = new Bar(2);
const bar3 = new Bar(&quot;3&quot;);
console.log(bar1 + bar2);
console.log(bar1 + bar3);
// 结果
3  // 数字
13 // 字符串</code></pre></li></ol></li></ul><ul id="f4d526a8-99cc-429e-9967-d897e42d399b" class="bulleted-list"><li style="list-style-type:square"><code>-</code>： 和<code>+</code>号类似，作为符号时可以将其他类型强制转化为数字类型<figure id="34de889f-a785-4e78-bd42-c7cf5bdccd7e" class="image"><a href="%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/NEGATIVE.png"><img style="width:432px" src="%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/NEGATIVE.png"/></a></figure><ul id="565fc41e-ce6a-489f-af47-c73019b0bf6b" class="bulleted-list"><li style="list-style-type:disc">作为<strong>双目减号操作符，</strong>和<code>+</code>是类似，但是只有数字相加的功能，<strong>没有拼接字符串</strong>的功能</li></ul></li></ul></li></ul><ul id="81b33c5f-597e-43ac-88a8-d862f8a0156e" class="bulleted-list"><li style="list-style-type:circle">其他将类型强制转化为原始类型的方法有toString(), valueOf()<figure id="685cd3fc-bca6-4f75-a391-41d06956a680" class="link-to-page"><a href="%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84Object%E6%96%B9%E6%B3%95.html"><span class="icon">📹</span>对象转原始值的Object方法</a></figure></li></ul></li></ul><ul id="7546d310-3622-4798-aafe-99d09451405c" class="bulleted-list"><li style="list-style-type:disc"><strong>优先级问题</strong><ul id="592df73a-69b3-494d-b965-a2e141d55f2c" class="bulleted-list"><li style="list-style-type:circle">对象转化为原始类型是根据对象的<strong>3种内置函数</strong>决定的</li></ul><ol type="1" id="39a734a4-4a03-48aa-83d3-df3e6ee0aecd" class="numbered-list" start="1"><li>如果有Symbol.toPrimitive()方法,优先调用再方法</li></ol><ol type="1" id="c05d275b-d37d-4940-9384-9a8598faad18" class="numbered-list" start="2"><li>调用valueOf()，如果转化为原始类型，则返回</li></ol><ol type="1" id="378655c8-0d06-4cfd-b210-854574a74490" class="numbered-list" start="3"><li>调用toString(),如果转化为原始类型，则返回</li></ol><ol type="1" id="3cd2584f-97d9-4bfb-b114-56a9fb0f43e4" class="numbered-list" start="4"><li>如果都没有返回原始类型，会报错<pre id="e7fe8e27-909b-43c7-babb-f87994529f88" class="code"><code>let obj2 = {
  value: 3,
  toString() {
    return new Date();
  },
};
let obj3 = {
  value: 4,
  valueOf() {
    return 2;
  },
  toString() {
    return 3;
  },
};
try {
  console.log(obj3 + 1);
  // 报错
  // 1.没有[Symbol.toPrimitive]()方法
  // 2.valueOf()方法继承对象默认方法，返回对象本身
  // 3.toString()被覆写，返回Date类型对象，不是原始类型
  // 4.不能转化为原始类型，报错
  // valueOf
  console.log(obj2 + 1);
} catch (error) {
  console.log(error);
}

// 打印
3
TypeError: Cannot convert object to primitive value
    at Object.&lt;anonymous&gt; (D:path\14-@@toPrimitive.js:72:20)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1155:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:77:12)
    at node:internal/main/run_main_module:17:47</code></pre><ul id="aaf26a2b-09d7-4c76-9561-f78bc5facddf" class="bulleted-list"><li style="list-style-type:disc">obj3 + 1结果为3，因为obj3定义了valueOf()，返回数字，是原始类型，所以可以成功转化</li></ul><ul id="a9211ca9-316b-43a7-9cf3-82f586ded736" class="bulleted-list"><li style="list-style-type:disc">而obj2即没有定义Symbol.toPrimitive,默认的valueOf方法返回对象本身，覆写的toString()返回对象，对象无法转化为原始类型，所以报错</li></ul></li></ol><ul id="3d2884c6-b927-4ac7-a703-a244f2554ab3" class="block-color-orange_background bulleted-list"><li style="list-style-type:circle">原理<ul id="38dce5fc-7204-4038-b133-2a0dce4623c6" class="bulleted-list"><li style="list-style-type:square">在内置操作需要将对象转化为原始数据值时，优先检查对象是否具有<code>Symbol.toPrimitive</code>方法</li></ul><ul id="6e8bba15-db64-4df5-8868-97e246e245b8" class="bulleted-list"><li style="list-style-type:square">如果有<code>Symbol.toPrimitive</code> 属性方法，则调用该方法，传递一个<strong>hint</strong>值</li></ul><ul id="00d9417e-b7b7-4b8c-abe9-d92413e872b6" class="bulleted-list"><li style="list-style-type:square"><code>hint</code>值由<strong>内置操作的原始值期望</strong>决定，通常有”number”, “string”, “default”三种</li></ul><ul id="ef089be1-9623-4dca-889a-fbb178c56b36" class="bulleted-list"><li style="list-style-type:square">例如，<code>-</code> 符号的首选原始类型就是”number”,而<code>+</code> 作为双目连接符号时(数字和字符串都不是首选)，它会传递<strong>”default”</strong></li></ul><ul id="3929fba4-5e24-4632-a108-a2b80407b39a" class="bulleted-list"><li style="list-style-type:square">同时，<code>String</code>作为一种字符串转化方式也会根据上面方法的优先级进行转化，对于Symbol.toPrimitive自然传入”string”</li></ul><pre id="f5a8bba2-e174-40c9-afba-427ad2a28556" class="code"><code>// toPrimitive
class Foo {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case &quot;number&quot;:
        return 3;
      case &quot;string&quot;:
        return &quot;string&quot;;
      case &quot;default&quot;:
        return &quot;default&quot;;
    }
  }
}
const foo = new Foo();
console.log(&quot;3&quot; + foo);
console.log(3 - foo);
console.log(3 + foo);
console.log(String(foo));
console.log(foo.toString());

// 输出
3default  // default
0  // 数字
3default  // default，双面+号传入的hint与另一个字符串无关
string // 传入string
[object Object] // 调用toString函数，与Symbol.toPrimitive无关</code></pre></li></ul><p id="6933bb64-bba2-4e84-8621-18ae1899879e" class="">
</p></li></ul><h1 id="4e7f2afa-fcdf-4cd2-851e-678f09eaab63" class="block-color-brown_background">11.Symbol.toStringTag</h1><h2 id="313e269f-bd4c-4cd2-b32b-4ea9db6d196e" class="">描述</h2><ul id="76bbe31d-47f4-4725-a346-276d2ab60a2c" class="bulleted-list"><li style="list-style-type:disc">ECMAScript规范，该符号作为一个对象属性表示<blockquote id="7d504a73-7afb-414f-acf5-9f4dabba7a69" class="">“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Obejct.prototype.toString()使用”</blockquote></li></ul><ul id="d15d56fc-39ea-438d-aabb-b7ecf9ff8ae7" class="bulleted-list"><li style="list-style-type:disc">关于toString()方法，可查找Symbol.toPrimitve中<mark class="highlight-blue"><strong><a href="%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84Object%E6%96%B9%E6%B3%95.html">关于其他对象转化为原始值的方法</a></strong></mark></li></ul><ul id="fa66bb9e-cf12-4fe7-ba4c-3d44648e8a01" class="bulleted-list"><li style="list-style-type:disc">每个对象的toString()方法都继承自Object,默认未覆写的toString()方法返回”[object Object]” 前者为对象，后者为对象类型</li></ul><ul id="727a2929-0e52-42b6-a281-26f111c80d63" class="bulleted-list"><li style="list-style-type:disc">在调用toString()方法时，会优先检索对象的[Symbol.toStringTag]属性指定的实例标识符，默认为”Object”即默认返回的后面的</li></ul><ul id="ca30b731-35d8-47a2-bb15-f67640ef217f" class="bulleted-list"><li style="list-style-type:disc">所有的<strong>内置类型</strong>已经指定了这个值，当时自定义类实例可以明确自定义</li></ul><h2 id="b055107a-6bc6-4d89-9d23-2f8b7475a2d1" class="">原理</h2><ol type="1" id="6a801099-7c3a-4176-bbda-728f15a0ecb3" class="numbered-list" start="1"><li>对象通过点调用toString()方法，会检查[String.toStringTag]属性实例标识符，默认是”Object”,所以大部分返回”[object Object]”</li></ol><ol type="1" id="098ba91c-cad3-4db4-973e-08d864d90930" class="numbered-list" start="2"><li>如果没有覆写toString()方法，那么正常情况下，toString()的返回值就会依据”[object type]”（type就是@@toStringTag）的原则</li></ol><ol type="1" id="48013601-9ad2-4b5f-99f1-9d465f80966b" class="numbered-list" start="3"><li>如果覆写了toString()方法,对象调用toString()就不会依据[Symbol.toStringTag]，除非覆写时使用该符号<pre id="1f0ec03b-9575-4e22-a24b-828a0a592255" class="code"><code>// toStringTag
class Bar {
  toString() {
    // 覆写
    return &quot;bar&quot;;
  }
}
class Foo {
  // 未覆写
}
const bar = new Bar();
const foo = new Foo();
console.log(bar.toString());
console.log(foo.toString());

class Baz extends Bar {
  [Symbol.toStringTag] = &quot;Baz&quot;;
}
class Foz extends Foo {
  [Symbol.toStringTag] = &quot;Foz&quot;;
}
const baz = new Baz();
const foz = new Foz();
console.log(baz.toString());
console.log(foz.toString());

const toString = Object.prototype.toString;

console.log(toString.call(bar));
console.log(toString.call(foo));
console.log(toString.call(baz));
console.log(toString.call(foz));

// 打印
bar // 覆写的，未设置toStringTag
[object Object] // 默认情况的toString
bar // 继承了覆写的toString()方法，设置了toStringTag
[object Foz] // 设置了toStringTag，未覆写
[object Object]  
[object Object]
[object Baz]
[object Foz]
// 后面是个依据[object type]的原则进行打印，前两个未设置toStringTag所以默认为Object</code></pre></li></ol><h1 id="1b40c8bc-e2a0-4027-8d13-9f3df580df3b" class="block-color-yellow_background">12.Symbol.unscopables</h1><div></div><h2 id="41521b17-66bc-4c13-85e5-475a201d3b67" class="">描述</h2><ul id="b1126bf9-7a28-4296-a2d1-cb1890557aa8" class="bulleted-list"><li style="list-style-type:disc">根据ECAMScript规范，这个符号作为一个属性表示<blockquote id="3f2d8062-d525-4e8c-b5ae-9b52eb6f7c7e" class="">“一个对象，该对象所有的以及继承的属性，都会从关联对象的with环境绑定中排除”</blockquote></li></ul><div><h2 id="dee1206a-b886-42f1-8ee1-fcbac56351da" class="">with语句</h2><ul id="edb35b08-7b16-45a9-9dd4-b931cf42e38c" class="bulleted-list"><li style="list-style-type:disc">该语句用于将代码的作用域设置到一个特定的对象中</li></ul><h3 id="238c3cc3-f62f-4fed-9890-840644ff1582" class="">语法</h3><pre id="e8d43a01-b644-4d92-9e3d-f00a4f18916d" class="code"><code>with(expression) {
	statement;
}</code></pre><h3 id="c79e7ccc-0355-471c-8b02-a89e1e979047" class="">作用</h3><ul id="6d86ebb3-4f53-43a0-a79d-0408cb3decbc" class="bulleted-list"><li style="list-style-type:disc">使用with语句的目的主要是为了简化多次使用同一个对象的工作，如<pre id="63bd5dc0-e98d-4d0e-b553-3ad6969d5d01" class="code"><code>var qs = location.search.substring(1);
var hostName = location.hostName;
var url = location.href;</code></pre><ul id="7f45f176-a871-4835-9a0a-afc889ae085e" class="bulleted-list"><li style="list-style-type:circle">这三个语句都使用了location对象</li></ul><ul id="ba2a2de5-7738-40ea-a321-34ac24ea6b83" class="bulleted-list"><li style="list-style-type:circle">或者说这三个语句都可以在location的作用域下使用（就像document可以在window环境下使用一样）</li></ul></li></ul><ul id="ad830bdf-c664-46ce-aca9-cffbb28b2f4b" class="bulleted-list"><li style="list-style-type:disc">所以可以使用with语句设置一下location作用域，直接使用location对象下的属性<pre id="764898d8-9fb3-4401-b6bb-11b3f390b84d" class="code"><code>with(location) {
	var qs = search.substring(1);
  var hostName = hostName;
	var url = href;
}</code></pre></li></ul><h3 id="b5aa35e0-d651-45d8-bfa1-e4512538d4cb" class="">局限性</h3><ul id="7062ada1-887c-4ae4-855a-26c6c071d8c1" class="bulleted-list"><li style="list-style-type:disc">有了<strong>解构赋值</strong>后，这种方式就作用不大了</li></ul><ul id="a1e2d25c-2c38-46e9-a005-e08a97ac5421" class="bulleted-list"><li style="list-style-type:disc">with非常耗费性能，严格模式下的with语句会报错</li></ul><ul id="8b3062d4-1806-4fdf-a22b-e40f03c63009" class="bulleted-list"><li style="list-style-type:disc">建议不要使用with语句</li></ul></div><h2 id="72286073-d92e-45fb-be5f-875554dcc96d" class="">Symbol.unscopables与with</h2><ul id="6c1d0c04-18ca-443d-a81f-f08237753a33" class="bulleted-list"><li style="list-style-type:disc">[Symbol.unscopables]属性作用域使用with的一个对象环境下</li></ul><ul id="c524a554-27ae-4651-a249-50717ab7d5f2" class="bulleted-list"><li style="list-style-type:disc">将with的一个或者一些属性和该with环境解绑</li></ul><ul id="28822a62-b5a1-4b97-95be-0d86cb2fa548" class="bulleted-list"><li style="list-style-type:disc">[Symbol.unscopables]属性是一个对象，键值对为with环境下的对象的属性，值为布尔值</li></ul><ul id="60460c15-96b1-4156-a05a-4fd7c57804cb" class="bulleted-list"><li style="list-style-type:disc">设置了该with环境下对象的一个属性值为false则将其和with环境<strong>解绑</strong></li></ul><h2 id="cd46e243-1c38-48ce-b44b-c67266b7a597" class="">解绑</h2><ul id="860ba1dc-0b73-43ca-ab8e-70eaa426a9b5" class="bulleted-list"><li style="list-style-type:disc">解绑即为环境下对象的属性不再属于该环境</li></ul><ul id="c7519400-7c58-4272-8eea-70eb3d0a40e9" class="bulleted-list"><li style="list-style-type:disc">例如<pre id="2a1840ff-1c5f-457c-9a7e-9eddd597b979" class="code"><code>// with语句 performance是global的一个属性
with (performance) {
  var name = nodeTiming.name;
  var nodeStart = nodeTiming.nodeStart;
  var time = timeOrigin;
  console.log(name, nodeStart, time);
}
// 打印
node 0.38970017433166504 1653232629259.427</code></pre><ul id="723dcbb8-91cc-4c67-a611-29c102252328" class="bulleted-list"><li style="list-style-type:circle">通过with语句可以直接使用performance中的属性</li></ul></li></ul><ul id="7e998b9a-85d7-45b9-a23f-ae31b6c9b3f0" class="bulleted-list"><li style="list-style-type:disc">设置performance的unscopables属性就可以自定义那些属性不可使用<pre id="b4e4201a-6e25-4863-a5f9-c8653b102feb" class="code"><code>// 使用unscopables设置解绑
performance[Symbol.unscopables] = {
  timeOrigin: true,
};
try {
  with (performance) {
    var name = nodeTiming.name;
    var nodeStart = nodeTiming.nodeStart;
    var time = timeOrigin;
    console.log(name, nodeStart, time);
  }
} catch (error) {
  console.log(&quot;ReferenceError&quot;);
}
// 打印
ReferenceError</code></pre><p id="98cfba66-4368-41a6-bcb9-e245ed1a668b" class="">⇒ timeOrigin属性被解绑，无法使用，所以在performance环境下没有该变量，报引用错误</p></li></ul><h2 id="6fe1cd93-8f10-43bb-a567-352a9f0c7ad9" class="">使用</h2><ul id="10b6d0da-a0cb-4ad7-ba71-472c0501be6d" class="bulleted-list"><li style="list-style-type:disc"><a href="%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7.html">不推荐使用with</a>，所以也不要使用[Symbol.unscopables]</li></ul><p id="5270880d-04df-4849-a2eb-eccde72d7115" class="">
</p></div></article></body></html>