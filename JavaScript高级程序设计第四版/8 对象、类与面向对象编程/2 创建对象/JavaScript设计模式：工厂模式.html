<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>JavaScript设计模式：工厂模式</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style><link rel="stylesheet" href="../../../style.css"></head><body><article id="26bafd6a-c51f-4471-87c3-37bd21aed56c" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/gradients_10.jpg" style="object-position:center 40%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🖥️</span></div><h1 class="page-title">JavaScript设计模式：工厂模式</h1></header><div class="page-body"><p id="d347967b-9dd6-4665-9934-0026f7c352e5" class="">参考</p><figure id="b311c3ef-6a3f-4495-9aaa-38ef0e6751d4"><a href="https://segmentfault.com/a/1190000014196851" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">从ES6重新认识JavaScript设计模式(二): 工厂模式</div><div class="bookmark-description">工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 如果只接触过JavaScript这门语言的的人可能会对 抽象这个词的概念有点模糊，因为JavaScript一直将 abstract作为保留字而没有去实现它。如果不能很好的理解 抽象 的概念，那么就很难理解工厂模式中的三种方法的异同。所以，我们先以一个场景去简单的讲述一下抽象和工厂的概念。 想象一下你的女朋友生日要到了，你想知道她想要什么，于是你问她：&quot;亲爱的，生日要到了你想要什么生日礼物啊？&quot; 正巧你女朋友是个猫奴，最经迷上了抖音上的一只超级可爱的苏格兰折耳猫，她也很想要一只网红同款猫。 于是她回答你说：&quot;亲爱的，我想要一只动物。&quot; 你心平气和的问她：&quot;想要什么 动物 啊？&quot; 你女友说：&quot;我想要 猫科动物 。&quot; 这时你内心就纳闷了，猫科动物有老虎，狮子，豹子，猞猁，还有各种小猫，我哪里知道你要什么？ 于是你问女友：&quot;你要哪种猫科动物啊？&quot; &quot;笨死了，还要哪种，肯定是小猫咪啊，难道我们家还能像迪拜土豪那样养老虎啊！&quot;你女朋友答道。 &quot;好好， 那你想要哪个 品种 的猫呢？&quot;你问道 &quot;我想要外国的品种, 不要中国的土猫&quot; 你女友傲娇的回答到。 这时你已经快奔溃了，作为程序员的你再也受不了这种挤牙膏式的提问，于是你哀求到：&quot;亲爱的，你就直接告诉我你到底想要哪个品种，哪个颜色，多大的猫？&quot; 你女友想了想抖音的那只猫，回答道：&quot;我想要一只灰色的，不超过1岁的苏格兰短耳猫！&quot; 于是，你在女友生日当天到全国最大的 宠物批发市场里面去，挑了 一只&quot;灰色的，不超过1岁的苏格兰短耳猫&quot; 回家送给了你女友, 圆了你女友拥有网红同款猫的梦想!</div></div><div class="bookmark-href"><img src="https://static.segmentfault.com/main_site/2ff9cb3c/favicon.ico" class="icon bookmark-icon"/>https://segmentfault.com/a/1190000014196851</div></div><img src="https://static.segmentfault.com/main_site/2ff9cb3c/touch-icon.png" class="bookmark-image"/></a></figure><figure id="c2982992-d214-4140-b60b-45ef95f0f4f2"><a href="https://zhuanlan.zhihu.com/p/474342971" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">JavaScript 设计模式（四）：抽象工厂模式</div><div class="bookmark-description">通过上一章的 小焱：JavaScript 设计模式（三）：工厂模式 了解了 工厂模式 ，这节我们将进一步了解抽象工厂模式 工厂模式 （Factory Pattern），根据输入的不同返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是将对象的创建与对象的实现分离。 抽象工厂模式(Abstract Factory)就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。 JS中是没有直接的抽象类的，abstract是个保留字，但是还没有实现，因此我们需要在类的方法中抛出错误来模拟抽象类，如果继承的子类中没有覆写该方法而调用，就会抛出错误。 面向对象的语言里有抽象工厂模式，首先声明一个抽象类作为父类，以概括某一类产品所需要的特征，继承该父类的子类需要实现父类中声明的方法而实现父类中所声明的功能： 我们知道 JavaScript 并不强面向对象，也没有提供抽象类（至少目前没有提供），但是可以模拟抽象类。用对 new.target 来判断 new 的类，在父类方法中 throw new Error() ，如果子类中没有实现这个方法就会抛错，这样来模拟抽象类： 下面用 JavaScript 将上面介绍的饭店例子实现一下。 首先使用原型方式： 这里的 Dish 类就是抽象产品类，继承该类的子类需要实现它的方法 eat。 上面的实现将产品的功能结构抽象出来成为抽象产品类。事实上我们还可以更进一步，将工厂类也使用抽象类约束一下，也就是抽象工厂类，比如这个饭店可以做菜和汤，另一个饭店也可以做菜和汤，存在共同的功能结构，就可以将共同结构作为抽象类抽象出来，实现如下： 这样如果创建新的饭店，新的饭店继承这个抽象饭店类，那么也要实现抽象饭店类，这样就都具有抽象饭店类制定的结构。 抽象工厂模式的通用实现 我们提炼一下抽象工厂模式，饭店还是工厂（Factory），菜品种类是抽象类（AbstractFactory），而实现抽象类的菜品是具体的产品（Product），通过工厂拿到实现了不同抽象类的产品，这些产品可以根据实现的抽象类被区分为类簇。主要有下面几个概念： Factory ：工厂，负责返回产品实例； AbstractFactory ：虚拟工厂，制定工厂实例的结构； Product ：产品，访问者从工厂中拿到的产品实例，实现抽象类； AbstractProduct ：产品抽象类，由具体产品实现，制定产品实例的结构； 下面是通用的实现，原型方式略过： 如果希望增加第二个类簇的产品，除了需要改一下对应工厂类之外，还需要增加一个抽象产品类，并在抽象产品类基础上扩展新的产品。 我们在实际使用的时候不一定需要每个工厂都继承抽象工厂类，比如只有一个工厂的话我们可以直接使用工厂模式，在实战中灵活使用。 抽象工厂模式的优缺点 抽象模式的优点： 抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦； 抽象模式的缺点： 扩展新类簇的产品类比较困难，因为需要创建新的抽象产品类，并且还要修改工厂类，违反开闭原则； 带来了系统复杂度，增加了新的类，和新的继承关系； 抽象类创建出的结果不是一个真实的对象实例，而是一个类簇，它指定了类的结构，这也就区别于简单工厂模式创建单一对象，工厂模式创建多类对象。 通过抽象工厂，就可以创建某个类簇的产品，并且也可以通过 instanceof 来检查产品的类别，也具备该类簇所必备的方法。 目录： 点击返回设计模式</div></div><div class="bookmark-href"><img src="https://static.zhihu.com/heifetz/favicon.ico" class="icon bookmark-icon"/>https://zhuanlan.zhihu.com/p/474342971</div></div><img src="https://picx.zhimg.com/v2-ba22311d6de672d6d7ed73f76df0a4b1_720w.jpg?source=172ae18b" class="bookmark-image"/></a></figure><h1 id="e07aba7c-c704-4251-8d48-e392100f863e" class="">1. 工厂模式</h1><h2 id="3177854a-4894-4a91-bf7f-4b0d5e819306" class="">1.1 概念</h2><ul id="7e03f221-7384-4dcb-8bf8-1e21610cc384" class="bulleted-list"><li style="list-style-type:disc">工厂模式是用来创建对象的一种最常用的设计模式<ul id="e22d5929-78d9-4983-ba5f-4d5bf7c4f5f2" class="bulleted-list"><li style="list-style-type:circle">在不暴露创建对象的逻辑下，将<strong>逻辑封装</strong>在一个函数中</li></ul><ul id="bf1915bd-1b7c-4756-8b94-d9d5d4daaa64" class="bulleted-list"><li style="list-style-type:circle">通过调用这个函数可以不断地创建<strong>同一结构</strong>的对象，这个函数就被视为一个工厂</li></ul><ul id="81a89b9a-3b8c-44f5-aed2-129f896dd2c3" class="bulleted-list"><li style="list-style-type:circle">在JavaScript中，将创建一种对象的逻辑封装在一个函数并视它为一个对象创建工厂，通过这个工厂来创建对象的模式叫做<strong>工厂模式</strong></li></ul></li></ul><ul id="79636f98-fc10-4ece-ae7e-cbdd43ee55f9" class="bulleted-list"><li style="list-style-type:disc">工厂模式根据<strong>抽象程度</strong>不同可分为三种<ul id="80a2761d-bb4c-480f-b304-c6a7b64fc65d" class="bulleted-list"><li style="list-style-type:circle"><strong>简单工厂</strong></li></ul><ul id="50792093-e498-453a-bcef-7d4dc8536d84" class="bulleted-list"><li style="list-style-type:circle"><strong>工厂方法</strong></li></ul><ul id="da4a5013-aa31-4416-8525-4f6f249feb1a" class="bulleted-list"><li style="list-style-type:circle"><strong>抽象工厂</strong></li></ul></li></ul><h2 id="1d705491-19d7-4baa-8b20-626c25f360d0" class="">1.2 抽象（abstract）</h2><ul id="82a96846-4f04-4c2a-8527-ba72d9806c3d" class="bulleted-list"><li style="list-style-type:disc">只了解JavaScript的开发者不是很好理解<strong>抽象（abstract），</strong>因为JavaScript一直把<strong>abstract作为</strong>保留字没有被实现，所以很难理解三种工厂模式的异同</li></ul><ul id="d9b9cb11-60dd-4fac-b4a7-c877c0cfde84" class="bulleted-list"><li style="list-style-type:disc">下面是一个理解<strong>抽象</strong>和<strong>工厂</strong>的例子<figure class="block-color-orange_background callout" style="white-space:pre-wrap;display:flex" id="782d4aab-9aed-4701-b0b7-77efca00f7c5"><div style="font-size:1.5em"><span class="icon">⚪</span></div><div style="width:100%"><mark class="highlight-gray">比如说：我要去一个大型的</mark><strong><mark class="highlight-gray">体育用品店</mark></strong><mark class="highlight-gray">买一个</mark><strong><mark class="highlight-gray">篮球</mark></strong><mark class="highlight-gray">，但是店里除了篮球以外还有</mark><strong><mark class="highlight-gray">足球、网球</mark></strong><mark class="highlight-gray">等等其他各种各样的体育用品，由于第一次来到这家店，对店内商品摆放位置不熟悉，短时间内想要找到它可能有点困难，于是我找到</mark><strong><mark class="highlight-gray">售货员</mark></strong><mark class="highlight-gray">，并告诉他我想要买个</mark><strong><mark class="highlight-gray">球</mark></strong><mark class="highlight-gray">，然后他问我：“你要买什么</mark><strong><mark class="highlight-gray">类型</mark></strong><mark class="highlight-gray">的球”，我说我要买一个7号的篮球，在售货员的帮助下我很快就找到了想要的篮球</mark>。</div></figure><ul id="51401778-014a-473c-a2a2-a1fffe912b6f" class="bulleted-list"><li style="list-style-type:circle">买到的篮球可以被看作一个实例对象，体育用品店可以看作是一个工厂<ul id="d20c3e05-6fb0-47ef-a4e9-0660acfa71c2" class="bulleted-list"><li style="list-style-type:square">可以认为这个体育用品店是一个工厂函数，这个工厂函数中有着各种各样的体育用品</li></ul><ul id="bfed5cd8-18e0-4368-a4f4-caf8599c7965" class="bulleted-list"><li style="list-style-type:square">如何获取到实例？<ul id="e075f262-3589-47cc-9a5c-15bbe92466a8" class="bulleted-list"><li style="list-style-type:disc">获取篮球的方式是向售货员表示要一个7号的篮球</li></ul><ul id="0a53c8f7-d503-41a8-b400-81c4f9cb8f60" class="bulleted-list"><li style="list-style-type:disc">即，给体育用品店（工厂函数）传递了正确的参数——“7号的篮球”</li></ul></li></ul></li></ul><ul id="a8ecbf3f-17e6-46ef-a339-15679bbf7576" class="bulleted-list"><li style="list-style-type:circle">第一次告诉售货员需求时，他不能明白我想要买什么类型的球，因为我说的太<strong>抽象</strong><ul id="b1ad0159-faa0-49de-b864-b2744f734c32" class="bulleted-list"><li style="list-style-type:square">我说我想买个<strong>球，</strong>但是球分为很多类型，没有具体到某一件商品</li></ul><ul id="d2e5dfba-c209-4285-8825-907f4bc9239b" class="bulleted-list"><li style="list-style-type:square">这种将<strong>复杂事务的一个或多个共有特征抽取出来的思维过程</strong>就是<strong>抽象</strong></li></ul></li></ul></li></ul><h1 id="d796b44e-c6d6-44c5-9822-d2391264521d" class="">2. 三种工厂模式</h1><h2 id="d6091440-644b-4772-8706-0fe7c4544cb9" class="">2.1 简单工厂模式（Simple Factory Pattern）</h2><ul id="e7d0dccb-789f-46d6-98c2-1380fe4db4be" class="bulleted-list"><li style="list-style-type:disc">简单工厂模式又称为<strong>静态工厂模式</strong>，由一个工厂对象决定去创建某一种产品对象类的实例。主要用于创建同一类对象</li></ul><ul id="0d77b543-d9ca-4d0a-990c-0ccee91a85db" class="bulleted-list"><li style="list-style-type:disc">上述体育用品店（工厂）实例化球类的例子如下<pre id="aae88a51-d2c4-4e3f-b599-ff47a8b6cde5" class="code code-wrap"><code>// 简单工厂模式
// 篮球基类
var Basketball = function () {
  this.info = &quot;篮球盛行于美国&quot;;
};
Basketball.prototype = {
  getMember() {
    console.log(&quot;每个队伍需要5名球员&quot;);
  },
};
// 足球基类
var Football = function () {
  this.info = &quot;足球在世界上很受欢迎&quot;;
};
Football.prototype = {
  getMember() {
    console.log(&quot;每个队伍需要11名球员&quot;);
  },
};
// 网球基类
var Tennis = function () {
  this.info = &quot;李娜在中国网球界内是顶尖高手&quot;;
};
Tennis.prototype = {
  getMember() {
    console.log(&quot;每个队伍需要1名球员&quot;);
  },
};
// 运动工厂
var SportsFactory = function (name) {
  switch (name) {
    case &quot;篮球&quot;:
      return new Basketball();
    case &quot;网球&quot;:
      return new Tennis();
    case &quot;足球&quot;:
      return new Football();
    default:
      console.log(&quot;请传递正确的参数&quot;);
      break;
  }
};
let basketball = SportsFactory(&quot;篮球&quot;);
console.log(basketball);
basketball.getMember();</code></pre><ul id="324df205-7542-4502-84b0-e9328b7ea4bc" class="bulleted-list"><li style="list-style-type:circle"><code>SportsFactory</code> 就是一个简单工厂，这个函数包含三个构造函数，可以创建三种的体育用品的球类</li></ul><ul id="758a698e-8f54-49ad-b43e-bce85960cdc2" class="bulleted-list"><li style="list-style-type:circle">只需要传递“篮球”，“足球”，“网球”这三种可选的参数就可以获得对应的实例对象</li></ul></li></ul><ul id="a3ea66e1-330d-4261-bcde-7ec937fefd43" class="bulleted-list"><li style="list-style-type:disc">简单工厂模式的优点<ul id="77f675f6-502f-4036-b294-29838dcbfd68" class="bulleted-list"><li style="list-style-type:circle">只需要传递一个正确的参数就可以获取想要的对象实例</li></ul><ul id="6f77dcfb-b49a-4e20-ba91-a255b235bf35" class="bulleted-list"><li style="list-style-type:circle"><strong>不需要</strong>知道工厂根据传递的参数创建对象的具体细节</li></ul></li></ul><ul id="9217a3fb-1665-4b60-894f-13671c645e38" class="bulleted-list"><li style="list-style-type:disc">简单工厂模式的缺点<ul id="fc5fa0ee-0605-4221-84cb-ab6de3fbfc7c" class="bulleted-list"><li style="list-style-type:circle">在工厂函数内包含了<strong>所有</strong>对象的创建逻辑（构造函数）和判断逻辑的代码</li></ul><ul id="732154b9-d4f9-44d8-9df4-2a644c2f799c" class="bulleted-list"><li style="list-style-type:circle">每增加一个新的构造函数（增加一个需要创建的对象实例）就需要修改判断逻辑</li></ul><ul id="bb890688-f7bd-49b6-8b59-4922212211df" class="bulleted-list"><li style="list-style-type:circle">当工厂需要创建的对象不是3个而是30个或者更多时，这个函数就会成为庞大的超级函数，难以<strong>维护</strong></li></ul></li></ul><ul id="adf6bf7a-b4cb-4c6b-bd7b-c5c3604b4118" class="bulleted-list"><li style="list-style-type:disc">简单工厂应用场景<ul id="d9db7813-b1d3-4949-a7d7-f144f3a85900" class="bulleted-list"><li style="list-style-type:circle">只作用于创建的对象<strong>数量较少</strong></li></ul><ul id="3b77d46b-dbc3-44d2-875d-b3dd9add71e5" class="bulleted-list"><li style="list-style-type:circle">对象的创建<strong>逻辑不复杂</strong></li></ul></li></ul><h2 id="f28cc52b-1d42-4680-b333-92dbd6f5d8a6" class="">2.2 工厂方法模式（Function Factory Pattern）</h2><ul id="81a2433b-5dec-4763-ab2f-9a18d5a60d5a" class="bulleted-list"><li style="list-style-type:disc">工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类<ul id="94975e02-6af9-4a42-a99a-bf7c0a8dfaba" class="bulleted-list"><li style="list-style-type:circle">如上面的方法中，创建对象的过程在<code>SportsFactory</code> 中就直接<code>new</code> 出来了</li></ul><ul id="5ae518b8-f948-40ad-a265-7a71dc477e69" class="bulleted-list"><li style="list-style-type:circle">但是在工厂方法中，需要将创建对象的过程推迟到一个<code>AbstractFactory</code> 的子类（XXFacroty）中，让这个子类专门进行创建对象的功能</li></ul></li></ul><ul id="56c6b1ae-f818-49d3-9e90-67033032ba8c" class="bulleted-list"><li style="list-style-type:disc"> 但是在JavaScript中<strong>很难</strong>像传统面向对象那样去实现创建抽象类<ul id="28d56313-d3c9-443c-815e-7c13db43d22b" class="bulleted-list"><li style="list-style-type:circle">所以只需要参考工厂方法模式的核心思想：将创建对象工作推迟到子类中</li></ul><ul id="faa24148-aa8c-4bfd-835d-6c2ab9f9d51c" class="bulleted-list"><li style="list-style-type:circle">所以我们可以将<code>SportsFactory</code> （工厂方法）看作是一个实例化对象的工厂类（而非工厂函数）</li></ul><ul id="304cd7a8-524c-430f-be74-6ca84fd4e67d" class="bulleted-list"><li style="list-style-type:circle">每次要创建对象时，先创建一个<code>SportsFactory</code> 的实例，这个实例应该包含所有的构造函数</li></ul><ul id="4a95fe34-0a67-40e6-8e3e-3ce197fa19b6" class="bulleted-list"><li style="list-style-type:circle">想要创建对象时，调用<code>SportsFacroty</code> 实例中保存的对应构造函数即可</li></ul><ul id="aee7c095-501b-473b-88c3-19efd2e6c6be" class="bulleted-list"><li style="list-style-type:circle">为了使用<code>SportFactory</code> 直接创建对象，可以使用安全模式</li></ul></li></ul><ul id="fdca57ac-6cb8-49fc-b2fd-14dea8246194" class="bulleted-list"><li style="list-style-type:disc">实现<pre id="00ed1dd4-70de-4f5e-be8b-7e2a25ad8eeb" class="code code-wrap"><code>// 工厂是一个类，包含所有的构造函数
var SportsFactory = function (name) {
  if (this instanceof SportsFactory) {
    var s = new this[name]();
    return s;
  } else {
    return new SportsFactory(name);
  }
};
SportsFactory.prototype = {
  Basketball: function () {
    this.info = &quot;篮球盛行于美国&quot;;
    this.getMember = function () {
      console.log(&quot;篮球队员5人&quot;);
    };
  },
  Football: function () {
    this.info = &quot;足球在全世界都很流行&quot;;
    this.getMember = function () {
      console.log(&quot;足球队需要11人&quot;);
    };
  },
  Tennis: function () {
    this.info = &quot;李娜是中国网球的顶尖选手&quot;;
    this.getMember = function () {
      console.log(&quot;网球是单人项目&quot;);
    };
  },
};

const football = SportsFactory(&quot;Football&quot;);
console.log(football);
football.getMember();
// 打印
Football { info: &#x27;足球在全世界都很流行&#x27;, getMember: [Function (anonymous)] }
足球队需要11人</code></pre><ul id="927e29bd-5fe5-4ba5-85d4-763b4e0ff8e3" class="bulleted-list"><li style="list-style-type:circle">上述这段代码很好的解决了每添加一个构造函数就需要修改两处代码的问题，在简单工厂模式中<ul id="6d95048a-b845-4c85-8d0c-b08b829efd40" class="bulleted-list"><li style="list-style-type:square">需要新增一个构造函数</li></ul><ul id="798db3ae-abaa-496e-acb3-3becda8e5e23" class="bulleted-list"><li style="list-style-type:square">需要修改工厂函数，增加可构造的函数</li></ul></li></ul><ul id="4360b8a5-030e-4b8a-a913-1baa49b4e89c" class="bulleted-list"><li style="list-style-type:circle">而在工厂方法模式中，只需要在工厂类中新增可构造函数即可</li></ul></li></ul><ul id="1afd0925-a3d9-4346-88de-c44baea1bd33" class="bulleted-list"><li style="list-style-type:disc">例如加一个乒乓球构造函数<pre id="b14bc4c2-10e4-4879-8e13-6dc30cde6d75" class="code code-wrap"><code>SportsFactory.prototype = {
	...
	Pingpang: function () {
    this.info = &quot;中国的乒乓球是世界霸主&quot;;
    this.getMember = function () {
      console.log(&quot;乒乓球由单人和双人项目&quot;);
    };
  },
}</code></pre></li></ul><ul id="a1b85658-4eea-482a-bcbf-9dae5067ee0c" class="bulleted-list"><li style="list-style-type:disc">因为将<code>Basketball</code>, <code>Football</code>,等构造函数保存到了<code>SportFactory.prototype</code> 中，这意味这必须实例化<code>SportFactory</code> 函数才能进行以上对象的创建；使用安全模式仅仅是为了直接调用工厂函数也能创建对象，如果不使用安全模式，则需要进行两次实例化，如下<pre id="2368e573-5ebe-4d17-92a6-9c95b492bb90" class="code code-wrap"><code>SportsFactory = function () {};
SportsFactory.prototype = {
  Basketball: function () {
    this.info = &quot;篮球盛行于美国&quot;;
    this.getMember = function () {
      console.log(&quot;篮球队员5人&quot;);
    };
  },
  Football: function () {
    this.info = &quot;足球在全世界都很流行&quot;;
    this.getMember = function () {
      console.log(&quot;足球队需要11人&quot;);
    };
  },
  Tennis: function () {
    this.info = &quot;李娜是中国网球的顶尖选手&quot;;
    this.getMember = function () {
      console.log(&quot;网球是单人项目&quot;);
    };
  },
  Pingpang: function () {
    this.info = &quot;中国的乒乓球是世界霸主&quot;;
    this.getMember = function () {
      console.log(&quot;乒乓球有单人和双人项目&quot;);
    };
  },
};
const sf = new SportsFactory();
const pingpang = new sf.Pingpang();
console.log(pingpang);
pingpang.getMember();
// 打印
Pingpang { info: &#x27;中国的乒乓球是世界霸主&#x27;, getMember: [Function (anonymous)] }
乒乓球由单人和双人项目</code></pre><ul id="9683e1fe-eef4-4323-b5e3-04c69a351cff" class="bulleted-list"><li style="list-style-type:circle">一旦任何一个地方忘记<code>new</code>，都会导致无法正常获取到<code>pingpang</code> 所以需要使用安全模式</li></ul></li></ul><h2 id="bfad10e1-e207-4a89-931c-392b4cf9a85a" class="">2.3 抽象工厂模式（Abstract Factory Pattern）</h2><ul id="0851e295-28aa-436c-9b13-a217dd6e438c" class="bulleted-list"><li style="list-style-type:disc">抽象工厂模式（Abstract Factory Pattern）就是通过类的抽象使得业务适用于一个产品类簇（cu）的创建，而不负责某一类产品的实例</li></ul><ul id="4ccf3883-2906-4e1e-af74-84089b39a29b" class="bulleted-list"><li style="list-style-type:disc">抽象工厂的通用实现需要一下类或方法<ul id="c5d10088-906d-4155-a1b0-226ef532288b" class="bulleted-list"><li style="list-style-type:circle">Factory: 工厂，负责返回对象实例</li></ul><ul id="91dac88a-5970-4f77-bb01-12a148649ac9" class="bulleted-list"><li style="list-style-type:circle">AbstractFactory: 虚拟工厂，制定工厂实例的结构</li></ul><ul id="152c6c1c-73e6-4069-9fef-c0a2dab7df31" class="bulleted-list"><li style="list-style-type:circle">Product： 产品，访问者从工厂中拿到的产品对象实例，实现抽象类</li></ul><ul id="317ac195-13aa-41bf-85ef-e5994e30f36a" class="bulleted-list"><li style="list-style-type:circle">AbstractPorduct: 产品抽象类，有具体产品实现，制定产品实例的结构</li></ul></li></ul><ul id="371621f7-a8b0-4f81-8c58-d0f96a8bfdd9" class="bulleted-list"><li style="list-style-type:disc">可能不好理解，还是从体育用品店出发<ul id="009319df-278b-4682-a245-8e49e24f6299" class="bulleted-list"><li style="list-style-type:circle">体育用品店除了球外，还卖球拍，以及球鞋等</li></ul><ul id="bcf17d57-0146-4f98-a21e-2eb259dc8ade" class="bulleted-list"><li style="list-style-type:circle">如果我们使用工厂方法模式，那么每有一个具体的体育用品要卖就要在工厂函数中新增一个构造函数</li></ul><ul id="e5254b7a-029d-43f0-8cc5-a54c69a90fb7" class="bulleted-list"><li style="list-style-type:circle">当体育用品过多时，这个工厂就很拥挤了，且没有对球，球拍，球鞋的产品进行分类</li></ul><ul id="8fbe408b-cd20-45dc-942a-553abc08d86d" class="bulleted-list"><li style="list-style-type:circle">所以我们需要抽象出来一个工厂，这个抽象工厂制定实例的结构，如体育用品店能购买球，购买球拍等</li></ul><ul id="c8461889-1c8d-4915-8856-6adb04168954" class="bulleted-list"><li style="list-style-type:circle">而继承它的工厂<code>Factory</code> 应该实现虚拟工厂的制定的方法，从中获取制定的产品，如实现构造球的方法，根据球类型返回具体的球类</li></ul><ul id="c6f896e1-5f66-421a-aebb-f56726a6b4ef" class="bulleted-list"><li style="list-style-type:circle">而产品通用需要抽象，一种运动可以有球拍也可能没有球拍，我们创建一个抽象的排类来制定产品实例的结构，具体的是乒乓球拍还是网球拍需要继承抽象的排类来实现结构</li></ul></li></ul><ul id="9541d5f2-e7f3-4261-9548-cc6784ea3866" class="bulleted-list"><li style="list-style-type:disc">使用ES6的class的通用实现如下<pre id="97378070-346a-4f03-bcc0-60a797ad47f7" class="code code-wrap"><code>/* 工厂 抽象类 */
class AbstractFactory {
    constructor() {
        if (new.target === AbstractFactory) 
            throw new Error(&#x27;抽象类不能直接实例化!&#x27;)
    }
    
    /* 抽象方法 */
    createProduct1() { throw new Error(&#x27;抽象方法不能调用!&#x27;) }
}

/* 具体工厂类 */
class Factory extends AbstractFactory {
    constructor() { super() }
    
    createProduct1(type) {
        switch (type) {
            case &#x27;Product1&#x27;:
                return new Product1()
            case &#x27;Product2&#x27;:
                return new Product2()
            default:
                throw new Error(&#x27;当前没有这个产品 -。-&#x27;)
        }
    }
}

/* 抽象产品类 */
class AbstractProduct {
    constructor() {
        if (new.target === AbstractProduct) 
            throw new Error(&#x27;抽象类不能直接实例化!&#x27;)
        this.kind = &#x27;抽象产品类1&#x27;
    }
    
    /* 抽象方法 */
    operate() { throw new Error(&#x27;抽象方法不能调用!&#x27;) }
}

/* 具体产品类1 */
class Product1 extends AbstractProduct {
    constructor() {
        super()
        this.type = &#x27;Product1&#x27;
    }
    
    operate() { console.log(this.kind + &#x27; - &#x27; + this.type) }
}

/* 具体产品类2 */
class Product2 extends AbstractProduct {
    constructor() {
        super()
        this.type = &#x27;Product2&#x27;
    }
    
    operate() { console.log(this.kind + &#x27; - &#x27; + this.type) }
}


const factory = new Factory()

const prod1 = factory.createProduct1(&#x27;Product1&#x27;)
prod1.operate()                                                                     // 输出: 抽象产品类1 - Product1
const prod2 = factory.createProduct1(&#x27;Product3&#x27;)    // 输出: Error 当前没有这个产品 -。</code></pre></li></ul><ul id="eccf1451-a8e5-4b21-9a5c-0be57b09367c" class="bulleted-list"><li style="list-style-type:disc">从体育用品店中购买用品<pre id="00ecb44c-a913-40f1-ae3d-0ee6e538dfde" class="code code-wrap"><code>// 抽象工厂模式

class AbstractSportsFactory {
  constructor() {
    if (new.target === AbstractSportsFactory) {
      throw new Error(&quot;抽象类不能直接实例化！&quot;);
    }
  }
  // 抽象方法
  createBall() {
    throw new Error(&quot;抽象方法不能调用&quot;);
  }
  createShoes() {
    throw new Error(&quot;抽象方法不能调用&quot;);
  }
  createBats() {
    throw new Error(&quot;抽象方法不能调用&quot;);
  }
}
class SportsFactory extends AbstractSportsFactory {
  constructor() {
    super();
  }
  createBall(type) {
    switch (type) {
      case &quot;Pingpong&quot;:
        return new Pingpong();
      case &quot;Tennis&quot;:
        return new Tennis();
      case &quot;Basketball&quot;:
        return new Basketball();
      case &quot;Football&quot;:
        return new Football();
      default:
        throw new Error(`本店不提供${type}球`);
    }
  }
  createShoes(type) {
    switch (type) {
      case &quot;Pingpong&quot;:
        return new PingpongShoes();
      case &quot;Tennis&quot;:
        return new TennisShoes();
      case &quot;Basketball&quot;:
        return new BasketballShoes();
      case &quot;Football&quot;:
        return new FootballShoes();
      default:
        throw new Error(`本店不提供${type}鞋`);
    }
  }
  createBats(type) {
    switch (type) {
      case &quot;Pingpong&quot;:
        return new PingpongBats();
      case &quot;Tennis&quot;:
        return new TennisBats();
      default:
        throw new Error(`本店不提供${type}拍`);
    }
  }
}
class AbstractBall {
  constructor() {
    if (new.target === AbstractBall) {
      throw new Error(&quot;抽象产品不能直接实例化&quot;);
    }
    this.type = &quot;球&quot;;
  }
  play() {
    throw new Error(&quot;抽象方法不能直接调用&quot;);
  }
}
class AbstractShoes {
  constructor() {
    if (new.target === AbstractShoes) {
      throw new Error(&quot;抽象产品不能直接实例化&quot;);
    }
    this.type = &quot;球鞋&quot;;
  }
  wear() {
    throw new Error(&quot;抽象方法不能直接调用&quot;);
  }
}
class AbstractBats {
  constructor() {
    if (new.target === AbstractShoes) {
      throw new Error(&quot;抽象产品不能直接实例化&quot;);
    }
    this.type = &quot;球拍&quot;;
  }
  test() {
    throw new Error(&quot;抽象方法不能直接调用&quot;);
  }
}

class PingpongShoes extends AbstractShoes {
  constructor() {
    super();
  }
  wear() {
    console.log(&quot;穿上了乒乓球鞋&quot;);
  }
}
class TennisShoes extends AbstractShoes {
  constructor() {
    super();
  }
  wear() {
    console.log(&quot;穿上了网球鞋&quot;);
  }
}
class BasketballShoes extends AbstractShoes {
  constructor() {
    super();
  }
  wear() {
    console.log(&quot;穿上了篮球鞋&quot;);
  }
}
class FootballShoes extends AbstractShoes {
  constructor() {
    super();
  }
  wear() {
    console.log(&quot;穿上了足球鞋&quot;);
  }
}
class Football extends AbstractBall {
  constructor() {
    super();
  }
  play() {
    console.log(&quot;踢足球真好玩，可是不会踢&quot;);
  }
}
class Tennis extends AbstractBall {
  constructor() {
    super();
  }
  play() {
    console.log(&quot;讨厌网球，不喜欢打网球&quot;);
  }
}
class Basketball extends AbstractBall {
  constructor() {
    super();
  }
  play() {
    console.log(&quot;很想打篮球，但是打的很烂&quot;);
  }
}
class Pingpong extends AbstractBall {
  constructor() {
    super();
  }
  play() {
    console.log(&quot;会打乒乓球，乒乓球很好玩&quot;);
  }
}
class PingpongBats extends AbstractBats {
  constructor() {
    super();
  }
  test() {
    console.log(&quot;这个乒乓球拍质量怎么样啊&quot;);
  }
}
class TennisBats extends AbstractBats {
  constructor() {
    super();
  }
  test() {
    console.log(&quot;网球拍好重啊&quot;);
  }
}

const sf = new SportsFactory();
const pingpong = sf.createBall(&quot;Pingpong&quot;);
const basketballshoes = sf.createShoes(&quot;Basketball&quot;);
const tennisbats = sf.createBats(&quot;Tennis&quot;);

console.log(pingpong); // Pingpong { type: &#x27;球&#x27; }
pingpong.play(); // 会打乒乓球，乒乓球很好玩
console.log(basketballshoes); // BasketballShoes { type: &#x27;球鞋&#x27; }
basketballshoes.wear(); // 穿上了篮球鞋
console.log(tennisbats); // TennisBats { type: &#x27;球拍&#x27; }
tennisbats.test(); // 网球拍好重啊
try {
  const basketballbats = sf.createBats(&quot;Basketball&quot;);
} catch (error) {
  console.log(error.message); // 本店不提供Basketball拍
}
try {
  const a = new AbstractSportsFactory();
} catch (error) {
  console.log(error.message); // 抽象类不能直接实例化！
}</code></pre></li></ul><ul id="2a1b3af1-a385-4ba6-8052-92dbb61f045b" class="bulleted-list"><li style="list-style-type:disc">因为JavaScript没有直接的抽象类，<code>abstract</code> 只是一个保留字，为了模拟实现抽象类，需要在构造函数和抽象类方法中抛出错误<pre id="aea74d23-b210-46dd-80b3-0bb900eaf3e5" class="code code-wrap"><code>class AbstractSportsFactory {
  constructor() {
    if (new.target === AbstractSportsFactory) {
      throw new Error(&quot;抽象类不能直接实例化！&quot;);
    }
  }
  // 抽象方法
  createBall() {
    throw new Error(&quot;抽象方法不能调用&quot;);
  }
}</code></pre><ul id="5750d2f0-717e-474c-8d94-9e01bbb32ccb" class="bulleted-list"><li style="list-style-type:circle"> <a href="http://new.target"><code>new.target</code></a> 是是用来判断<code>new</code> 的是那个类的属性</li></ul></li></ul><ul id="a0a73397-4a94-4250-8f98-9f047d837387" class="bulleted-list"><li style="list-style-type:disc">抽象工厂模式的优点<ul id="efb60721-fec7-42e4-ab05-0e88f8444d3c" class="bulleted-list"><li style="list-style-type:circle">抽象产品类将产品的结构抽象出来，访问者不需要知道具体实现，只需要面向向产品的结构编程即可，从产品的具体实现解耦</li></ul></li></ul><ul id="66805ae5-e859-442e-a6da-42c007eaab85" class="bulleted-list"><li style="list-style-type:disc">抽象工厂模型的缺点<ul id="09ddc310-975f-4993-ac8b-a1a07538cdec" class="bulleted-list"><li style="list-style-type:circle">扩展新类簇的产品类比较困难，因为需要创建新的抽象产品，并且还需要修改工厂类，违反开闭原则，如体育用品店卖球衣，则需要构建抽象球衣类以及具体的球衣类，也要修改工厂类</li></ul><ul id="0b346b6a-77d5-4e5f-b45e-33cf65b03ae4" class="bulleted-list"><li style="list-style-type:circle">带来新的复杂度，增加新的类，和形的复杂关系</li></ul></li></ul><p id="0113b3d9-9e74-4269-8710-ea2a09efe2f2" class="">
</p><p id="5001ba78-82ec-4313-81be-3e8a78438194" class="">
</p></div></article></body></html>